need each page  fully detailed master prompts for each of the 22 pages of PeerLearn, covering every aspect of the app in depth, including hidden and visible elements, UI/UX requirements, responsive design (mobile and web), user workflows, user actions, backend logic, error handling, advanced functionality, content layout, visual feedback, testing/validation, and suggestions for enhancements. Due to the extensive nature of this request (22 pages with deep coverage), providing all prompts in a single response would be impractical given length constraints. Instead, I’ll provide a complete, deeply detailed master prompt for the Landing Page (/)* as a model, and a structured summary for the remaining 21 pages, with the same level of depth available for any specific page upon request. I’ll also include suggestions for the entire app to enhance its value and engagement. If you want the full prompt for any other page, please specify, and I’ll deliver it immediately.
comprehensive set of master prompts for each page in the PeerLearn platform, ordered sequentially as requested, starting with the Landing Page (/)* and progressing through the Role Selection Page (/register/), Role-Based Registration Pages (/register/learner/, /register/mentor/), Login Page (/login/), and Role-Based Dashboards (/dashboard/learner/, /dashboard/mentor/), followed by the remaining pages to complete the 22-page structure. Each prompt is crafted with the same depth as the Landing Page provided in the thinking trace, ensuring a premium, responsive web UI, real-time functionality, and adherence to Django, SQLite3, and Tailwind CSS (CDN) constraints. The workflow ensures users move from the Landing Page to role selection, role-specific registration, login, and finally to their respective dashboards, maintaining simplicity (2-3 clicks for key actions) and scalability for Replit deployment
PeerLearn Overview
PeerLearn is a premium EdTech platform for one-to-one live video learning, built with Django 4.2, SQLite3, and Tailwind CSS (CDN). It features real-time dashboards, ML-driven recommendations (Gemini API), WebRTC video, Razorpay payments, and a cohesive design system with glassmorphism, parallax effects, and immersive animations. The app ensures minimal steps (2-3 clicks for key actions), scalability, and accessibility across devices.


plan all ui after pormt say 

Enhance the premium parallax effect in a cool and impressive manner, while also designing a cohesive system with appealing visuals, including shadows, fonts, buttons, colors, and icons. Ensure that color values accurately represent brand values and promote a clean appearance across every page, whether in dark or light mode. Utilize regular and bold fonts, along with clear icons and advanced card designs.

Create comprehensive wireframes for both mobile and web, ensuring compatibility across all devices. Focus on inputs, outlines, transparency, visual hierarchy, contrast, balance, and consistency in actual design. Emphasize simplicity and provide feedback with click effects that respond to user actions. Optimize content placement, particularly in the mobile app's bottom navigation, to represent the app's importance with meaningful icons and dynamic click effects, including hover and focused center icons to enhance role relations.

Position the call-to-action (CTA) buttons centrally, keeping the audience's interests in mind. Avoid modifying or hiding the home indicator, and do not overlap the navigation bar with it. Strive for a clean design that is easy to tab through, keep labels short and neat, and explore creative as well as standard minimal layouts. Ensure each card label exudes color richness to engage users while reducing barriers by providing direct access to content. 

Consider important interaction principles, such as the cognitive, physical, and time effort a user expends to achieve their goals. Aim for minimal steps and quick value delivery, ensuring relevance in design. Focus on the thumb zone for mobile devices—ensuring it’s easy to reach even in stretched positions. Transform empty states into opportunities by incorporating CTA buttons and meaningful visual cues. 

Utilize immersive 3D designs, sustainable practices, and effects like glassmorphism that relate specifically to my EdTech app, incorporating light effects and glowing elements in buttons, cards, and action areas. Introduce subtle beams in specific areas to add dynamism while maintaining user engagement. Integrate animated visual elements as essential aspects of the interface, particularly for loading screens and transitions that convey depth and emotion. 

Employ modern grayscapes and smart micro-interactions that align with my EdTech features, including elements that relate to metaverse realities. Plan thoroughly for each page layout, analyzing all possibilities to achieve the best outcomes for mobile, web, UI, and compatibility across all devices.
Build PeerLearn, an advanced one-to-one live video learning platform using Django, SQLite3, and Tailwind CSS via CDN. Follow these instructions precisely:

Setup: Initialize a Replit project with Django 4.2, Channels, Razorpay, and SQLite3. Use .env for secrets (e.g., API keys).
Folder Structure: Organize into apps (users, sessions, payments, admin_panel, ml_recommendations, notifications), with static/, templates/, utils/, and media/. Use clean, descriptive file names (e.g., learner_views.py).
User Features:
Learners: Register with career goals (ML suggestions, spelling correction, all domains hidden until clicked). Track progress (sessions, status), view payment history (Paid/Failed/Refunded).
Mentors: Register with expertise (suggestions, spelling correction), optional intro video (≤5MB), certifications, LinkedIn, GitHub.


Payments: Integrate Razorpay with secure handling—retry failed payments 3x, offer refunds, log all attempts. Show history with status and support pop-ups.
Admin: Build a dashboard with charts (revenue, users), full control over users/sessions, and feedback display.
UI/UX: Use glassmorphism (blur: 12px), animations (fade-ins, ripples), horizontal scrolling cards. Ensure responsive design (desktop grid, mobile stacked with bottom nav).
Real-Time: Implement WebSocket via Channels for notifications, session updates, and video streaming (WebRTC, no delays).
ML: Add recommendations for career goals, mentors, and sessions, auto-displayed on dashboards.
Error Handling: Secure payments, user-friendly error messages (e.g., "Retry payment?"), fallback for video drops.
Testing: Test all flows (visitor, learner, mentor, admin), ensure mobile/desktop compatibility, and deploy on Replit.

Focus on simplicity (2-3 clicks to book), user satisfaction (premium feel), and mentor growth (70% earnings). Do not use React or other frameworks—only Django templates. Ensure maintainable, clean code with no deviations.



Master Prompt for Building PeerLearn: Step-by-Step
Objective: Build PeerLearn, a one-to-one live video learning platform that connects learners with mentors for personalized, scheduled sessions. The platform must be production-ready, scalable, secure, and deployed on Replit using Django 4.2 for backend and frontend (via Django templates), SQLite3 as the database, Tailwind CSS via CDN for styling, and WebRTC for real-time video. It should feature advanced UI/UX (glassmorphism, parallax effects, 3D elements), ML-driven recommendations, secure payments via Razorpay, and robust error handling. The platform supports four user roles: Visitor, Learner, Mentor, and Admin, with minimal user effort (e.g., 2-3 clicks to book a session), premium aesthetics, and mentor growth (70% commission). Follow these steps in order, completing each fully before proceeding, ensuring no React or other frameworks are used, and maintaining clean, maintainable code with no deviations.

Step 1: Initialize the Replit Environment
Goal: Set up a clean, secure Replit environment for development.
Actions:
Create a new Python project on Replit named "peerlearn."
Add only these libraries to requirements.txt: django, djangorestframework, django-channels, channels-redis, django-allauth, razorpay, celery, redis, python-decouple, sentry-sdk, pytest, pytest-django, black, isort, flake8. Install them using pip install -r requirements.txt.
Configure environment variables in Replit’s "Secrets" tab:
DJANGO_SECRET_KEY: A random, secure key.
RAZORPAY_KEY_ID: rzp_test_ebT608Q3yd4RCS (test mode).
RAZORPAY_KEY_SECRET: mGosJfwuEiL1GndUI2kicrL7 (test mode).
GEMINI_API_KEY: For ML recommendations (optional, stub if unavailable).
Create a .replit file with: run = "bash run.sh".
Create a run.sh script to automate startup:
Install dependencies, apply migrations, and start the server with Daphne for WebSocket support.
Initialize version control: Run git init and create a .gitignore file excluding .env, db.sqlite3, and media/.
Check:
Server starts without errors.
Only specified libraries are installed.
Environment variables load correctly.
Git is set up with proper exclusions.
Step 2: Set Up the Django Project Structure
Goal: Scaffold the Django project with modular apps and core configurations for scalability and maintainability.
Actions:
Run django-admin startproject peerlearn . to create the project in the root directory.
Create six Django apps for modularity: users, sessions, payments, admin_panel, ml_recommendations, notifications.
For each, run python manage.py startapp <app_name> and add to INSTALLED_APPS in settings.py.
Configure settings.py:
Add apps: users, sessions, payments, admin_panel, ml_recommendations, notifications, plus rest_framework, django_channels, django_allauth, django_cors_headers.
Set up CHANNEL_LAYERS for Redis to handle WebSocket communication.
Configure DATABASES to use SQLite3, with a stub for future PostgreSQL compatibility.
Set ASGI_APPLICATION = 'peerlearn.asgi.application' for WebSocket support.
Enable HTTPS, CSRF protection, and CORS lockdown.
Create a base template in templates/base.html:
Include Tailwind CSS via CDN.
Define a responsive layout with a glassmorphism container (backdrop-filter: blur(12px)).
Add placeholders for dynamic content ({% block content %}).
Set up folder structure:
static/: For CSS, JS, and images (e.g., css/base.css, js/webrtc.js).
templates/: For base and app-specific templates (e.g., sessions/dashboard.html).
utils/: For helper functions (e.g., error handling, ML utilities).
media/: For uploads (e.g., mentor_videos/, session_recordings/).
Use clean, descriptive file names (e.g., learner_views.py, payment_utils.py).
Check:
Server runs, and the Django admin interface is accessible.
Channels are configured for WebSocket support.
Base template renders with Tailwind CSS styling.
Folder structure is organized and maintainable.
Step 3: Build User Models and Authentication
Goal: Create a secure, role-based authentication system with multi-step registration and 2FA.
Actions:
Define a CustomUser model in users/models.py to support Learner, Mentor, and Admin roles:
Fields: role (choices: learner, mentor, admin), interests (text), bio (text), profile_picture (image), is_approved (boolean, default False for mentors).
Extend Django’s AbstractUser for compatibility.
Set AUTH_USER_MODEL = 'users.CustomUser' in settings.py.
Configure django-allauth for email-based login and social login (Google, GitHub).
Implement multi-step registration:
Learner: Step 1: Name, email, password. Step 2: Career goals (ML-driven suggestions, spelling correction). Step 3: Profile picture (optional).
Mentor: Step 1: Name, email, password. Step 2: Expertise (ML-driven suggestions, spelling correction), optional intro video (≤5MB), certifications, LinkedIn, GitHub. Step 3: Bio, profile picture.
Add two-factor authentication (2FA) via email codes, processed asynchronously with Celery.
Set role-based redirects after login:
Learners → /dashboard/learner/.
Mentors → /dashboard/mentor/ (or approval page if not approved).
Admins → /admin_panel/.
Use Django templates for all forms, styled with Tailwind CSS (glassmorphism cards, glowing inputs).
Check:
Users can register with role-specific forms and 2FA.
ML suggestions work for career goals and expertise.
Redirects are role-specific.
Templates are responsive and premium (no React or other frameworks).
Step 4: Define Database Models
Goal: Create all necessary database models to support sessions, bookings, payments, and notifications, and seed test data.
Actions:
Define models in their respective apps:
sessions/models.py:
Session: Fields for mentor, learner, title, description, schedule, price, status (active/canceled), recording (file).
Booking: Fields for learner, session, status (pending/confirmed).
payments/models.py:
Payment: Fields for booking, amount, status (paid/failed/refunded), transaction ID.
notifications/models.py:
Notification: Fields for user, message, timestamp, read status.
ml_recommendations/models.py:
Recommendation: Fields for user, session, score (for ML-driven suggestions).
Run migrations: python manage.py makemigrations and python manage.py migrate.
Seed test data:
10 sessions with varied mentors, schedules, and prices.
5 bookings with mixed statuses.
5 notifications (e.g., "Session booked").
3 payment records (paid, failed, refunded).
Check:
Models are created and migrated successfully.
Test data is accessible via Django admin.
File uploads (e.g., recordings) are stored in media/.
Step 5: Implement REST API Endpoints
Goal: Build secure, RESTful APIs for core functionality (sessions, bookings, payments, notifications).
Actions:
Use Django REST Framework (DRF) to create serializers and viewsets in each app (e.g., sessions/serializers.py, sessions/viewsets.py).
Define endpoints:
/api/sessions/: List, create, update, delete sessions.
/api/bookings/: Manage bookings.
/api/payments/: View payment history, process refunds.
/api/notifications/: List and mark notifications as read.
Register endpoints in urls.py using a DRF router.
Secure APIs with token authentication (rest_framework.authentication.TokenAuthentication) and rate limiting (django-ratelimit).
Add CORS headers to restrict access to trusted domains.
Check:
APIs return correct data (test with tools like Postman).
Authentication and rate limiting are enforced.
CORS is properly configured.
Step 6: Set Up WebSocket for Real-Time Features
Goal: Enable real-time video streaming, notifications, and session updates using WebSocket.
Actions:
Configure Django Channels in sessions/routing.py for WebSocket connections:
Define a consumer for video sessions (e.g., VideoConsumer).
Route: /ws/video/<room_id>/ for video signaling.
Implement WebRTC for real-time video:
Use Google STUN servers for peer-to-peer connections.
Stub a TURN server for NAT traversal (future scalability).
Add WebSocket for notifications in notifications/routing.py:
Route: /ws/notifications/ for real-time alerts.
Update peerlearn/asgi.py to include WebSocket routing.
Ensure WebSocket connections are authenticated and secure.
Check:
WebSocket connections establish instantly (test with browser dev tools).
Video streams without delay using WebRTC.
Notifications update in real-time.
Step 7: Implement Advanced UI/UX
Goal: Create a premium, responsive UI/UX with glassmorphism, parallax effects, and immersive 3D elements across all pages.
Actions:
Design System:
Colors: Primary (Calm Blue, #007BFF), Accent (Vibrant Orange, #FF5733), Neutral (Light Gray, #F5F5F5; Dark Gray, #121212).
Typography: Poppins Bold (24–32px) for headings, Inter Regular (14–16px) for body.
Icons: Feather Icons (outline for light mode, filled for dark).
Shadows: Soft shadows (box-shadow: 0 4px 12px rgba(0,0,0,0.1)).
Glassmorphism: backdrop-filter: blur(12px) for cards/modals.
Parallax Effect:
Add multi-layered scrolling on the landing page with educational visuals (e.g., floating books).
Optimize with lightweight SVGs and CSS transforms.
Cards:
Rounded corners (rounded-xl), glassmorphism, hover tilt (transform: perspective(1000px) rotateY(5deg)).
Rich labels (orange for "Live," purple for "Premium").
Buttons/CTAs:
Centered, glowing orange gradient (#FF5733 to #FF8C00), ripple on click.
Scale-down effect (transform: scale(0.95)).
Inputs:
Outlined, transparent, glowing orange border on focus.
Real-time validation with shake animations for errors.
Mobile:
Bottom nav with icons (Home, Search, Learn, Profile).
Focused "Learn" icon enlarges on selection.
Thumb zone: Interactive elements within easy reach.
Empty States:
Illustrations (e.g., "No sessions yet") with CTAs ("Explore Now").
3D & Effects:
Subtle 3D tilt on cards, glowing buttons (box-shadow: 0 0 10px rgba(255,87,51,0.5)).
Light beams for onboarding highlights.
Micro-Interactions:
Ripple on button clicks, slide transitions, animated spinning book for loading.
Dark/Light Modes:
Toggle switch with session persistence.
Check:
UI is responsive across devices (desktop grid, mobile stacked).
Glassmorphism and parallax effects render smoothly.
Micro-interactions provide feedback.
Step 8: Build Payment Integration
Goal: Implement secure payment processing with Razorpay, including history and error handling.
Actions:
Integrate Razorpay in payments/views.py:
Create orders for paid sessions.
Verify payments and update booking status.
Show payment history in dashboard/learner/ with statuses: Paid, Failed, Refunded.
Handle errors:
Retry failed payments 3 times.
Offer refund option (admin-approved).
Display pop-up for support ("Retry payment or request refund?").
Log all transactions in payments/models.py for auditing.
Check:
Payments process successfully.
History displays correct statuses.
Error handling works (retries, refunds, pop-ups).
Step 9: Add ML-Driven Recommendations
Goal: Implement ML recommendations for career goals, expertise, and session suggestions.
Actions:
Use a lightweight ML model (e.g., Gemini API or simple embeddings) in ml_recommendations/utils.py.
For learners:
Suggest career goals during registration (e.g., "Machine Learning Engineer" for "Mach").
Recommend sessions on /dashboard/learner/ based on interests.
For mentors:
Suggest expertise during registration (e.g., "Python" for "Pyhton").
Recommend learners for new sessions on /dashboard/mentor/.
Store recommendations in ml_recommendations/models.py.
Auto-display recommendations on dashboards with horizontal scrolling cards.
Check:
Suggestions are accurate and relevant.
Recommendations render in dashboards.
Spelling corrections work.
Step 10: Build Pages and Workflows
Goal: Create all pages with premium UI/UX, define user workflows, and ensure seamless navigation.
Actions:
Pages (14 total):
Landing Page (/)
UI: Hero with parallax effect, horizontal session/mentor cards.
Workflow: Visitors browse, click "Register" (Learner/Mentor) or "Login".
Backend: Fetch public sessions via API.
Login Page (/login/)
UI: Centered glassmorphism card, glowing inputs, social login buttons.
Workflow: Enter credentials, 2FA → Redirect to role-specific dashboard.
Backend: Allauth authentication.
Learner Registration (/register/learner/)
UI: Multi-step form (name/email, career goals, picture).
Workflow: Complete steps → Auto-login → /dashboard/learner/.
Backend: Save user data, trigger ML suggestions.
Mentor Registration (/register/mentor/)
UI: Similar form (expertise, video, links).
Workflow: Submit → "Pending Approval" → Admin approves → /dashboard/mentor/.
Backend: Save mentor profile.
Learner Dashboard (/dashboard/learner/)
UI: Sidebar (desktop) or bottom nav (mobile), progress ring, ML-recommended sessions, payment history.
Workflow: Browse, book, join sessions, view history.
Backend: Fetch sessions, bookings, payments.
Mentor Dashboard (/dashboard/mentor/)
UI: Stats (sessions, earnings), session creation form, learner requests.
Workflow: Create sessions, accept requests, withdraw earnings.
Backend: Calculate earnings, manage sessions.
Admin Panel (/admin_panel/)
UI: Charts (revenue, users), user/session management, feedback display.
Workflow: Approve mentors, manage platform, view analytics.
Backend: Custom admin views, real-time data.
Session Detail & Booking Modal
UI: Glassmorphism modal, session info, "Book Now" CTA.
Workflow: View details, book (free/paid) → /cart/ for paid.
Backend: Check availability, create booking.
Cart & Checkout (/cart/)
UI: Payment form, status display.
Workflow: Pay via Razorpay → Confirm booking.
Backend: Process payment, update status.
Live Session Room (/session/<room_id>/)
UI: Video (70%), glassmorphism sidebar with tools (whiteboard, chat).
Workflow: Join, interact, leave → Feedback modal.
Backend: WebRTC streaming, tool integration.
Feedback & Rating Modal
UI: 5-star rating, comment box.
Workflow: Submit feedback → Save to admin panel.
Backend: Store ratings/comments.
Profile & Settings (/profile/)
UI: Form for editing details, notifications, privacy.
Workflow: Update profile → Save changes.
Backend: Update user model.
Mentor Withdrawal & Transaction History (/mentor/withdrawal/)
UI: Earnings summary, transaction list, "Withdraw" CTA.
Workflow: Request withdrawal → Admin approves.
Backend: Process withdrawals, log transactions.
Error Pages (401, 403, 404, 500)
UI: Friendly messages, retry CTAs.
Workflow: Handle errors gracefully.
Backend: Custom error views.
Navigation:
Desktop: Fixed sidebar with icons and labels.
Mobile: Bottom nav (Home, Search, Learn, Profile) with enlarging center icon.
Workflows:
Visitor: Browse landing → Register/Login.
Learner: Register → Browse → Book → Pay → Join → Feedback.
Mentor: Register → Create sessions → Host → Withdraw.
Admin: Login → Manage → Analyze.
Check:
All pages render with premium UI/UX.
Workflows are seamless (2-3 clicks for key actions).
Navigation is intuitive across devices.
Step 11: Implement Error Handling and Security
Goal: Ensure robust error handling and security across the platform.
Actions:
Error Handling:
Payments: Retry 3x, offer refund, display pop-up ("Retry or refund?").
Video: Auto-reconnect (3 retries), show "Reconnecting…" message.
Forms: Inline validation (e.g., "Email taken").
APIs: Graceful error responses (e.g., 429 for rate limits).
Security:
Enforce HTTPS on Replit.
Use CSRF tokens for forms, CORS lockdown (django-cors-headers).
Implement 2FA with Celery.
Rate limit APIs (django-ratelimit).
Sanitize user inputs to prevent XSS/SQL injection.
Logging:
Use Sentry to log errors (e.g., payment failures, video drops).
Store transaction logs in payments/models.py.
Check:
Errors are user-friendly and actionable.
Security measures prevent unauthorized access.
Logs capture critical events.
Step 12: Test and Optimize
Goal: Ensure the platform is bug-free, performant, and ready for deployment.
Actions:
Write tests with pytest for 90%+ coverage:
Unit tests for views, APIs, and models.
Integration tests for WebRTC, payments, and WebSocket.
Test on multiple devices:
Desktop: Chrome, Firefox.
Mobile: iOS Safari, Android Chrome.
Simulate edge cases:
Low bandwidth (3G) for video streaming.
Payment failures and refunds.
Concurrent bookings.
Optimize performance:
Compress images (WebP) in static/.
Cache API responses with Redis.
Minimize CSS/JS for fast loading.
Verify UI/UX:
Glassmorphism, parallax, and 3D effects render smoothly.
Micro-interactions (ripples, transitions) enhance engagement.
Check:
Tests pass with high coverage.
Platform performs well under stress.
UI/UX is consistent across devices.
Step 13: Deploy on Replit
Goal: Deploy the platform on Replit with continuous running.
Actions:
Configure .replit and run.sh for persistent server operation.
Set up Sentry for real-time error monitoring.
Test deployment:
Access all pages (landing, dashboards, session room).
Verify WebSocket and WebRTC functionality.
Confirm payment processing and ML recommendations.
Monitor logs for issues (e.g., memory usage, Redis connection).
Check:
Platform is live and accessible.
All features (video, payments, recommendations) work as expected.
Server runs continuously without crashes.
Step 14: Document and Plan for Future Updates
Goal: Document the platform and outline future enhancements.
Actions:
Create a README.md with:
Setup instructions (Replit, environment variables).
Feature overview (video, payments, recommendations).
User workflows (visitor, learner, mentor, admin).
Plan future updates:
PostgreSQL for production-grade database.
TURN server for WebRTC scalability.
AR/VR integration for metaverse classrooms.
Advanced ML models for personalized learning paths.
Outline maintenance:
Regular dependency updates.
Monitoring with Sentry.
User feedback integration via admin panel.
Check:
Documentation is clear and complete.
Future updates are feasible and aligned with platform goals.
Master Prompt for Building PeerLearn (Fully Comprehensive with Enhanced Functionality)
Project Name: PeerLearn
Responsive Design
Each page uses a mobile-first approach, starting with a single-column layout for mobile and expanding to multi-column grids for larger screens. For example, the Landing Page stacks content vertically on mobile, while desktops show a 1200px-wide grid. Media queries ensure images and videos scale without distortion, and lazy loading improves performance.

Premium UI/UX
Glassmorphism (e.g., backdrop-filter: blur(12px)) is used for cards and sidebars, creating a frosted-glass effect. Subtle shadows (shadow-lg) and hover effects (e.g., cards lifting with transform: translateY(-4px)) add depth. Buttons pulse with @keyframes pulse for a premium feel, and Lottie animations (e.g., "rocket launch" loader) enhance engagement.

Smooth Transitions and Effects
CSS transitions (e.g., transition: all 0.3s ease) ensure smooth fade-ins and slide animations. Hover effects include color shifts and glows, while micro-interactions like button ripples provide feedback. Real-time updates via WebSocket keep the interface dynamic, ensuring a seamless experience.

Survey Note: Detailed Design of PeerLearn Pages for Responsive, Premium, and Smooth UI/UX
This survey note provides an in-depth analysis of how each page in the PeerLearn platform is designed to achieve a responsive, premium, and smooth UI/UX, focusing on content sizing, transitions, hover effects, shadows, and overall cleanliness. The approach is informed by best practices for educational platforms, ensuring a modern, gamified, video-centric experience that competes with top apps like Coursera or Skillshare.

1. Importance of Responsive, Premium, and Smooth Design
Responsive web design is critical for educational platforms, where users access content on diverse devices, from smartphones to desktops. Research suggests that responsive design improves user engagement and accessibility, as highlighted in "Responsive Web Design: Best Practices and Considerations" (Toptal®). For PeerLearn, a premium UI/UX with smooth transitions and effects is essential to create a professional, engaging experience, aligning with user expectations for modern EdTech apps. The use of glassmorphism, shadows, and animations, as seen in platforms like Notion, enhances perceived value and usability.

The survey draws on case studies like "Adapting To A Responsive Design (Case Study)" (Smashing Magazine), which emphasizes moving from separate mobile sites to responsive designs for consistency. Performance optimization, as noted in "Responsive Web Design | Best Practices For Accessibility" (LevelAccess), ensures fast loading (<300ms) with lazy-loaded images and minified assets, crucial for educational content delivery.

2. General Design Principles
To achieve a responsive, premium, and smooth UI/UX, the following principles are applied:

Responsive Layouts: CSS Grid and Flexbox with breakpoints at 360px (mobile), 768px (tablet), and 1200px (desktop), following "Responsive Web Design" (GeeksforGeeks).
Premium Aesthetics: Glassmorphism (backdrop-filter: blur(12px); background: rgba(255,255,255,0.6)), subtle shadows (shadow-lg), and hover effects (e.g., transform: translateY(-4px)) for depth.
Smooth Transitions: CSS transitions (e.g., transition: all 0.3s ease) for fade-ins, slide animations, and button ripples, enhanced by JavaScript libraries like GSAP or Anime.js.
Clean and Neat: Minimalistic design with ample white space, consistent typography (Poppins Bold for headlines, Inter Regular for body), and intuitive navigation, as per "Mastering Responsive Web Design: Best Practices for a Seamless User Experience" (Medium).
3. Detailed Page-by-Page Design
Below is a table summarizing each page's design, followed by a detailed breakdown:

Page	Content Sizing	Responsive Layout	Premium UI/UX	Smooth Transitions and Effects
Landing Page	Cards 300x400px, hero 600px height	Mobile: single-column, swipeable; Desktop: grid	Glassmorphism, hover lifts, Lottie loaders	Fade-ins, carousel slides, button ripples
Login Page	Form 300x300px, illustration 200x200px	Mobile: full-width, sticky button; Desktop: centered card	Glassmorphism, glow on focus, pulse buttons	Fade-in, loader animation, error shake
Learner Registration	Fields 300x48px, illustrations 200x200px	Mobile: full-screen, sticky "Next"; Desktop: card	Glassmorphism, slide transitions, tooltips	Slide left-to-right, confetti on finish
Mentor Registration	Same as learner, with additional media	Same as learner	Same as learner, with video preview	Same as learner, fade to approval
Learner Dashboard	Progress ring 100x100px, cards 300x400px	Mobile: bottom nav, swipeable; Desktop: sidebar + grid	Glassmorphism, real-time updates, badges	Fade-in sections, smooth carousel scrolls
Mentor Dashboard	Stats 150x100px, cards 300x200px	Mobile: bottom nav, vertical; Desktop: sidebar + grid	Glassmorphism, charts, streak tracker	Real-time stats, chart animations
Live Session Room	Video frames 400x300px, sidebar 400x600px	Mobile: full-width video, bottom sheet; Desktop: split view	Glassmorphism, hover controls, transcript	Smooth panel opens, video stream optimized
Feedback Modal	Stars 40x40px, textarea 360x100px	Full-screen on mobile, centered on desktop	Glassmorphism, fade-in, glow on stars	Scale-up, fade-out, confetti on submit
Profile & Settings	Avatar 100x100px, fields 300x48px	Mobile: full-width; Desktop: centered card	Glassmorphism, hover on save, toggle effects	Fade-in, ripple on save, smooth form updates
Admin Panel	Tables 100% width, responsive	Mobile: scrollable tables; Desktop: grid	Glassmorphism, hover on rows, real-time	Fade-in rows, smooth table interactions
Error Pages	Card 400x400px, illustration 200x200px	Full-width on mobile, centered on desktop	Glassmorphism, fade-in, clean error message	Smooth fade-in, clear back button action
a. Landing Page
Content Display: Hero section with headline ("Learn 1:1 with Top Mentors"), Lottie "rocket launch" animation (300x300px), and CTAs ("Get Started"). Featured Sessions (4 cards, 300x400px), Top Mentors (3x2 grid, 350x250px), and Testimonials (3 cards, 400x200px) are dynamically loaded.
Responsive Sizing: Mobile (360px): Single-column, swipeable carousels; Tablet (768px): 2-column mentor grid, hero text 24px; Desktop (1200px): 1200px max-width grid, fixed nav.
Premium UI/UX: Glassmorphism on cards (backdrop-filter: blur(12px)), subtle shadows (shadow-lg), hover lifts on cards (transform: translateY(-4px)), and button pulses (@keyframes pulse).
Smooth Transitions and Effects: Hero fades in (0.5s), carousel slides from right, button click ripples, and Lottie loader ("rocket launch") for API calls.
Clean and Neat: Ample white space, consistent typography (Poppins Bold 32px, Inter Regular 16px), and minimal icons (Heroicons).
b. Login Page
Content Display: Centered form (300x300px) with email/password inputs, social login buttons, and "unlocking door" illustration (200x200px).
Responsive Sizing: Mobile: Full-width card, sticky "Login" button; Desktop: 400x600px centered card; Tablet: 350px wide.
Premium UI/UX: Glassmorphism on card, input border glows orange on focus (border-orange-500), button pulse animation, and subtle shadows.
Smooth Transitions and Effects: Card fades in (0.5s), illustration slides up, button ripples on click, and Lottie "spinning globe" loader during authentication.
Clean and Neat: Minimalistic form with white space, error messages inline with shake animation for clarity.
c. Registration Pages (Learner and Mentor)
Content Display: Multi-step wizard with progress bar (10px height), illustrations (200x200px per step), and form fields (300x48px each).
Responsive Sizing: Mobile: Full-screen, progress dots, sticky "Next" button; Desktop: 500x700px card, progress bar.
Premium UI/UX: Glassmorphism on card, slide transitions between steps, gamified tooltips ("Complete Step 1 to unlock badge!"), and hover effects on buttons.
Smooth Transitions and Effects: Slide left-to-right (0.5s), confetti animation on finish (Lottie), real-time validation with AJAX, and smooth error messages.
Clean and Neat: Step-by-step flow with clear progress indicators, minimal clutter, and consistent spacing.
d. Learner Dashboard
Content Display: Sidebar (250px) with links, header (80px) with search and notifications, and main content (progress ring 100x100px, session cards 300x400px, mentor cards 200x250px).
Responsive Sizing: Mobile: Bottom nav (60px), single-column, swipeable carousels; Tablet: 2-column grid, collapsible sidebar; Desktop: Fixed sidebar, grid layout.
Premium UI/UX: Glassmorphism on cards and sidebar, real-time updates via WebSocket, badges with unlock animations, and hover lifts on cards.
Smooth Transitions and Effects: Sections fade in sequentially (0.3s stagger), carousel scrolls with momentum, button pulses, and Lottie "spinning book" loader.
Clean and Neat: Organized grid with white space, consistent typography, and minimal icons for navigation.
e. Mentor Dashboard
Content Display: Similar to learner, with stats cards (150x100px), session cards (300x200px), and charts (600x300px).
Responsive Sizing: Mobile: Bottom nav, vertical stacking; Tablet: 2-column charts, collapsible sidebar; Desktop: Fixed sidebar, grid.
Premium UI/UX: Glassmorphism, streak tracker with fire emoji (🔥), badges with confetti, and hover effects on buttons.
Smooth Transitions and Effects: Real-time stats updates, chart animations (Chart.js), and smooth modal opens for profile popups.
Clean and Neat: Segmented layout for clarity, minimal clutter, and consistent design language.
f. Live Session Room
Content Display: Video frames (400x300px each), controls (40x40px icons), and sidebar (400x600px) with chat, transcript, and agenda.
Responsive Sizing: Mobile: Full-width video, bottom sheet for sidebar; Tablet: Adjustable split view; Desktop: 70% video, 30% sidebar.
Premium UI/UX: Glassmorphism on sidebar, hover glow on controls, and smooth panel transitions.
Smooth Transitions and Effects: Videos fade in, sidebar slides from right, transcript auto-scrolls, and optimized WebRTC for no delays.
Clean and Neat: Minimalistic, distraction-free layout with clear controls and real-time updates.
g. Feedback Modal
Content Display: Rating stars (40x40px), comment textarea (360x100px), and submit button (200x50px).
Responsive Sizing: Full-screen on mobile, centered on desktop (400x300px).
Premium UI/UX: Glassmorphism, stars glow on hover, and smooth fade-in.
Smooth Transitions and Effects: Scales up on open (0.3s), fades out on submit, and Lottie "checkmark" on success.
Clean and Neat: Minimal form with clear feedback, no clutter.
h. Profile & Settings
Content Display: Avatar (100x100px), form fields (300x48px), toggles (150x40px), and save button (200x50px).
Responsive Sizing: Mobile: Full-width card; Desktop: Centered 600x800px card.
Premium UI/UX: Glassmorphism, hover on save button, and toggle effects.
Smooth Transitions and Effects: Fields fade in, save button ripples, and smooth form updates via AJAX.
Clean and Neat: Organized form with white space, consistent spacing.
i. Admin Panel
Content Display: Tables (100% width), actions (150x40px buttons).
Responsive Sizing: Mobile: Scrollable tables; Desktop: Grid layout.
Premium UI/UX: Glassmorphism on panels, hover on rows, and real-time updates.
Smooth Transitions and Effects: Rows fade in, smooth table interactions, and Lottie "loading table" loader.
Clean and Neat: Tabular layout with filters, minimal clutter.
j. Error Pages
Content Display: Card (400x400px), illustration (200x200px), and back button (200x50px).
Responsive Sizing: Full-width on mobile, centered on desktop.
Premium UI/UX: Glassmorphism, smooth fade-in, and clean error message.
Smooth Transitions and Effects: Card fades in (0.3s), clear back button action.
Clean and Neat: Reassuring design with minimal elements.
4. Implementation Details
CSS and JavaScript: Use Tailwind CSS via CDN (<script src="https://cdn.tailwindcss.com"></script>) for rapid styling, with custom CSS for animations (@keyframes pulse, transition: all 0.3s ease). JavaScript handles WebRTC (RTCPeerConnection) and Lottie animations (<script src="https://cdnjs.cloudflare.com/ajax/libs/lottie-web/5.12.2/lottie.min.js"></script>).
Performance Optimization: Lazy-load images, minify CSS/JS, and use WebSocket for real-time updates to ensure <300ms load times, as per "Responsive Web Design | Best Practices For Accessibility" (LevelAccess).
Accessibility: Follow WCAG guidelines with ARIA labels, keyboard navigation, and high-contrast mode, ensuring inclusivity.
5. Why This Design Works
Responsive: Adapts to all devices with flexible layouts and media queries, as per "Responsive Web Design" (GeeksforGeeks).
Premium: Glassmorphism, shadows, and animations create a modern, Instagram-like feel, enhancing perceived value.
Smooth: CSS transitions and animations ensure fluid interactions, with real-time updates via WebSocket for dynamic content.
Clean and Neat: Minimalistic design with white space and consistent typography ensures clarity and professionalism, aligning with "Mastering Responsive Web Design: Best Practices for a Seamless User Experience" (Medium).
Objective: You are "PeerLearn Builder," an expert full-stack AI agent tasked with creating PeerLearn, a cutting-edge, production-ready, one-to-one live video learning platform. The platform must deliver real-time, high-quality video sessions with no delays or buffering, featuring advanced Zoom-like capabilities (screen sharing, whiteboard, raise hand, recording, sound notifications) and additional features (AI transcription, gamified leaderboards, multi-language support, offline mode). Build this using only Django (Python) for backend and frontend (via Django templates), SQLite3 as the database, Django Channels for WebRTC signaling, and Tailwind CSS via CDN for styling—no React, Vue, or other frameworks. Deploy on Replit, ensuring security, scalability, and responsiveness across web (desktop, tablet) and mobile devices. The UI/UX must be premium, gamified, and video-centric, with glassmorphism, Lottie animations, advanced transitions, and real-time interactions. Follow the step-by-step instructions in order, completing each with automated tests, manual QA, and device-specific checks before proceeding. Adhere strictly to all requirements—deviations are unacceptable.
Importance of Dynamic Navigation
Dynamic navigation is a critical component for educational platforms, ensuring users see only relevant options based on their role (visitor, learner, mentor, admin) and current page. This approach reduces cognitive load, enhances usability, and aligns with research suggesting that clear, role-based navigation improves user engagement and satisfaction (The Rules for Modern Navigation). For PeerLearn, dynamic navigation is essential to cater to diverse user needs, such as learners browsing sessions, mentors managing bookings, and admins overseeing operations, while maintaining a premium, intuitive experience across web and mobile devices.

The master prompt emphasizes a "premium, gamified, and video-centric" UI/UX, which necessitates navigation that adapts seamlessly to user context. For instance, a visitor on the landing page sees general options like "Live Sessions" and "Mentors," while a logged-in learner sees "My Posts" and "My Bookings." This segmentation is supported by articles like "Higher Ed Navigation Best Practices" (Higher Ed Navigation Best Practices), which highlight the importance of tailoring navigation for different user types to reduce frustration and improve information access.

2. Detailed Analysis of Each Page
Below is a table summarizing the navigation items and content for each page, followed by a deeper dive into each:

Page	Navigation Items	Content Summary
Landing Page	Logo, Live Sessions, Mentors, About, Support, Login, Register	Hero section, featured sessions, top mentors, testimonials, footer with links
Login Page	Back to home, Register	Login form, social login options, forgot password link
Learner Registration (4 Steps)	Back, Next, Finish	Multi-step forms: Basic info, interests, career goal, profile picture
Mentor Registration (4 Steps)	Back, Next, Finish	Multi-step forms: Basic info, expertise, bio & media, availability
Learner Dashboard	Dashboard, Live Sessions, Mentors, My Posts, My Bookings, Cart, Profile, Settings, Logout	Progress overview, recommended sessions, browse mentors, posts, cart, bookings, profile
Mentor Dashboard	Dashboard, Create Session, Booking Requests, My Sessions, Analytics, Payments, Profile, Settings, Logout	Quick stats, create session, requests, sessions, analytics, payments, profile
Session Detail & Booking	Back to dashboard	Session details, booking options (free or paid)
Cart & Checkout	Back to dashboard, Proceed to payment	Cart list, total amount, payment form with Razorpay
Live Session Room	Leave Session	Video streams, controls, chat, transcript, agenda
Feedback Modal	None (modal)	Rating stars, comment textarea, submit button
Profile & Settings	Back to dashboard	Edit personal information, change password, toggle dark/light mode
Admin Panel	Users, Sessions, Payments, Approvals, Analytics, Logs, Error Alerts	Tables and forms for managing platform operations
Error Pages (401, 403, 404, 500)	Back to Home	Error message, illustration, back to home button
a. Landing Page
Navigation Items: Logo (links to home), Live Sessions, Mentors, About, Support, Login, Register. These items align with your specified "live sessions, mentors, About, Support" and add "Login" and "Register" for onboarding, ensuring visitors can explore or sign up.
Content: The hero section features a headline like "Learn 1:1 with Top Mentors" and CTAs ("Register as Learner," "Register as Mentor," "Login"). Featured sessions and top mentors are displayed in carousels or grids, dynamically loaded from the Session and CustomUser models, with real-time updates via WebSocket. Testimonials and a footer with links to "About," "Support," etc., enhance credibility and accessibility.
Why Dynamic? For non-logged-in users, this navigation is static, but once logged in, it transitions to role-specific options, ensuring a seamless flow.
b. Login Page
Navigation Items: Back to home, Register. Minimal navigation focuses on authentication, with "Register" providing an alternative path.
Content: Includes a login form (email, password), social login options (Google, Facebook), and a forgot password link, all styled with glassmorphism and animations for a premium feel.
Why Dynamic? After login, users are redirected to their dashboard, changing the navigation context.
c. Registration Pages (Learner and Mentor)
Navigation Items: Back, Next, Finish for each step. This linear navigation supports the multi-step wizard, ensuring users can navigate through the process easily.
Content: Learner steps include basic info, interests (with AI suggestions), career goals, and profile picture upload. Mentor steps add expertise, bio, media, and availability. Each step has illustrations (e.g., "waving hand," "rocket launch") and gamified tooltips, with slide transitions for a premium experience.
Why Dynamic? Navigation adapts per step, with "Finish" appearing only on the last step, ensuring clarity.
d. Learner Dashboard
Navigation Items: Dashboard, Live Sessions, Mentors, My Posts, My Bookings, Cart, Profile, Settings, Logout. These items cover all learner functionalities, aligning with your request for depth in features like "progress, performance, my learning, request, responses, cards, my sessions."
Content: Includes progress rings, recommended sessions (AI-driven), mentor browsing, posts form, cart, bookings, and profile editing. Real-time updates via WebSocket ensure dynamic data, with charts (Chart.js) for performance tracking.
Why Dynamic? Tailored for learners, showing only relevant options like "My Posts" for session requests, not mentor-specific items like "Create Session."
e. Mentor Dashboard
Navigation Items: Dashboard, Create Session, Booking Requests, My Sessions, Analytics, Payments, Profile, Settings, Logout. These items cover mentor needs, including "revenue, my sessions, request, responses," as you mentioned.
Content: Quick stats, session creation, booking requests, session management, analytics charts, and payment history, all with real-time updates. Gamified elements like streak trackers and badges enhance engagement.
Why Dynamic? Focuses on mentor-specific tasks, excluding learner options like "My Posts."
f. Session Detail & Booking Modal
Navigation Items: Back to dashboard. Minimal to keep focus on booking.
Content: Session details (title, description, mentor, time, price) with booking options, dynamically fetched via API.
Why Dynamic? Modal-based, ensuring users return to the dashboard after action.
g. Cart & Checkout
Navigation Items: Back to dashboard, Proceed to payment. Focuses on purchase flow.
Content: Cart list, total, and Razorpay integration, with real-time updates for cart changes.
Why Dynamic? Minimal, ensuring a streamlined payment process.
h. Live Session Room
Navigation Items: Leave Session. Minimal to maintain focus on the session.
Content: Video streams, controls (mute, share, whiteboard), and sidebar (chat, transcript, agenda), all with real-time synchronization via WebSocket.
Why Dynamic? No need for extensive navigation during a session, ensuring a distraction-free experience.
i. Feedback Modal
Navigation Items: None (modal). Focuses on feedback collection.
Content: Rating stars, comment textarea, submit button, with animations for a premium feel.
Why Dynamic? Not applicable, as it's a modal.
j. Profile & Settings
Navigation Items: Back to dashboard. Minimal for account management.
Content: Edit personal info, change password, toggle dark/light mode, with real-time updates for profile changes.
Why Dynamic? Ensures users return to their dashboard after updates.
k. Admin Panel
Navigation Items: Users, Sessions, Payments, Approvals, Analytics, Logs, Error Alerts. Tailored for administrative tasks.
Content: Tables and forms for managing platform operations, with real-time updates for approvals and logs.
Why Dynamic? Focuses on admin-specific functions, excluding user-facing options.
l. Error Pages
Navigation Items: Back to Home. Minimal to guide users back.
Content: Error message, illustration, and back button, with a premium design for user reassurance.
Why Dynamic? Ensures users can return to the main flow, adapting to error context.
3. Implementation of Dynamic Navigation
Dynamic navigation is implemented using Django templates with conditional logic. For example, in base.html, the navigation bar can include:

For non-logged-in users: {% if not user.is_authenticated %}<a href="/login">Login</a>{% endif %}
For learners: {% if user.role == 'learner' %}<a href="/posts">My Posts</a>{% endif %}
For mentors: {% if user.role == 'mentor' and user.is_approved %}<a href="/create-session">Create Session</a>{% endif %}
This ensures the navigation adapts based on user authentication and role, aligning with your request for "dynamic nav based each pages."
like #F5F5F5 (light gray) or #FFFFFF (white) for readability, with dark backgrounds (#121212) for modern aesthetics, ensuring contrast.
It seems likely that fonts should use dark colors (#333333) on light backgrounds and light colors (#F5F5F5) on dark, with sans-serif fonts like Open Sans for body and Montserrat for headings.
The evidence leans toward vibrant button colors like #007BFF (blue) for primary actions, #6C757D (gray) for secondary, and #DC3545 (red) for danger, with white text for contrast.
Hover effects should slightly darken buttons (e.g., #007BFF to #0056b3) and lift cards with shadows, enhancing interactivity and smoothness.
Background Colors
For a clean, professional look, use light backgrounds like #F5F5F5 or #FFFFFF, or a soft gradient like #E0F7FA for a themed feel. Dark backgrounds (#121212) can create a modern, sleek design but require high-contrast text for readability.

Font Colors
On light backgrounds, use #333333 for body text and #1A1A1A for headings. On dark backgrounds, use #F5F5F5 for body and #FFFFFF for headings, ensuring legibility with sans-serif fonts like Open Sans and bolder fonts like Montserrat.

Button Colors
Primary buttons should be #007BFF with white text, secondary #6C757D with white text, and danger buttons #DC3545 with white text. These colors stand out, aligning with action-oriented design principles.

Hover Effects
For buttons, darken the color on hover (e.g., #007BFF to #0056b3). For cards, use transform: translateY(-5px) with enhanced shadows, adding depth and interactivity.

Survey Note: Optimal Color Combinations for PeerLearn Pages
This survey note provides a comprehensive analysis of the best color combinations for PeerLearn's web pages, focusing on backgrounds, fonts, buttons, and hover effects to achieve a responsive, premium, and smooth UI/UX. The approach is informed by current web design trends for 2025, drawing on research from various sources to ensure a clean, neat, and engaging experience for educational platforms like PeerLearn, competing with apps like Coursera and Skillshare.

1. Importance of Color Combinations in Web Design
Color is a critical element in web design, influencing user perception, engagement, and accessibility. Research from "25 Examples of Perfect Color Combinations in Web Design | Codrops" (25 Examples of Perfect Color Combinations in Web Design | Codrops) highlights that color reactions are subjective but guided by color theory, impacting emotional responses and usability. For educational platforms, colors must balance professionalism, readability, and interactivity, as noted in "Website Design Trends for 2025: Suggested Color Combinations and Fonts | ControlF5" (Website Design Trends for 2025: Suggested Color Combinations and Fonts | ControlF5). The survey also considers performance, ensuring fast loading (<300ms) with optimized assets, as per "Responsive Web Design | Best Practices For Accessibility | LevelAccess" ([Responsive Web Design | Best Practices For Accessibility | LevelAccess]([invalid url, do not cite])).

2. General Design Principles
To achieve a premium, clean, and neat look, the following principles are applied:

Contrast and Readability: Ensure sufficient contrast between text and background, using tools like WebAIM's Contrast Checker (WebAIM's Contrast Checker).
Accessibility: Follow WCAG guidelines with ARIA labels and high-contrast modes, ensuring inclusivity for all users.
Smoothness: Use CSS transitions (e.g., transition: all 0.3s ease) and JavaScript animations for hover effects and micro-interactions, enhancing user feedback.
Consistency: Maintain a cohesive color palette across pages, aligning with PeerLearn's brand (Orange #FF5734, Purple #BE94F5, Yellow #FCCC42, Light Gray #F7F7F5, Dark Text #151515).
3. Detailed Color Combinations for Each Element
Below is a table summarizing recommended color combinations, followed by detailed explanations:

Element	Color Options	Hover/Effect	Rationale
Background	#F5F5F5 (Light Gray), #FFFFFF (White), #E0F7FA (Light Blue), #121212 (Dark Gray)	Gradient transitions for modern look	Light for readability, dark for modern aesthetics, ensures contrast.
Font (Body)	#333333 (Dark Gray) on light, #F5F5F5 (Light Gray) on dark	None, focus on legibility	High contrast for readability, aligns with accessibility standards.
Font (Headings)	#1A1A1A (Almost Black) on light, #FFFFFF (White) on dark	None, bold for emphasis	Stands out, enhances hierarchy, matches modern typography trends.
Buttons (Primary)	#007BFF (Blue) with #FFFFFF text	Darken to #0056b3 on hover	Blue is trusted, stands out, hover effect adds interactivity.
Buttons (Secondary)	#6C757D (Gray) with #FFFFFF text	Darken to #5a6268 on hover	Neutral, less prominent, hover effect for feedback.
Buttons (Danger)	#DC3545 (Red) with #FFFFFF text	Darken to #c82333 on hover	Red grabs attention, hover effect for critical actions like "Delete."
a. Background Colors
Options: Light backgrounds like #F5F5F5 or #FFFFFF provide a clean, professional look, ideal for educational content, as seen in "The 30 Best Website Color Schemes to Make Your Website More Compelling | Hostinger" (The 30 Best Website Color Schemes to Make Your Website More Compelling | Hostinger). Soft gradients like #E0F7FA add a themed feel, while dark backgrounds (#121212) create a modern, immersive interface, as suggested in "Website Design Trends for 2025: Suggested Color Combinations and Fonts | ControlF5" (Website Design Trends for 2025: Suggested Color Combinations and Fonts | ControlF5).
Hover/Effect: Use gradient transitions (e.g., background: linear-gradient(45deg, #FF5734, #BE94F5); transition: background 2s ease) for dynamic backgrounds, enhancing smoothness.
Rationale: Light backgrounds ensure readability, while dark backgrounds suit modern designs but require high-contrast text, aligning with "Applying Color Theory to Digital Displays | UXmatters" (Applying Color Theory to Digital Displays | UXmatters).
b. Font Colors
Options: On light backgrounds, use #333333 for body text and #1A1A1A for headings, ensuring high contrast for readability. On dark backgrounds, use #F5F5F5 for body and #FFFFFF for headings, as per USWDS color guidelines (Color | U.S. Web Design System (USWDS)).
Hover/Effect: No hover effects, focusing on legibility, but ensure font size (16px body, 24–32px headings) and line height for accessibility.
Rationale: High contrast ensures accessibility, with sans-serif fonts like Open Sans for body and Montserrat for headings, matching modern typography trends from "Designer-approved website color schemes | Canva" (Designer-approved website color schemes | Canva).
c. Button Colors
Options: Primary buttons use #007BFF (blue) with #FFFFFF text for trust and action, secondary #6C757D (gray) with #FFFFFF text for neutrality, and danger #DC3545 (red) with #FFFFFF text for urgency, as per "The Best Button Colors for Websites (Updated 2024) | Designerly" (The Best Button Colors for Websites (Updated 2024) | Designerly).
Hover/Effect: On hover, darken primary to #0056b3, secondary to #5a6268, and danger to #c82333, with subtle shadows or scale effects for feedback, as shown in "CSS Button Style – Hover, Color, and Background | FreeCodeCamp" (CSS Button Style – Hover, Color, and Background | FreeCodeCamp).
Rationale: These colors stand out, align with action-oriented design, and enhance conversion rates, ensuring a premium, interactive feel.
4. Implementation Details
CSS for Buttons with Hover Effects:
css

Copy
.button-primary {
  background-color: #007BFF;
  color: #FFFFFF;
  padding: 10px 20px;
  border: none;
  cursor: pointer;
  transition: background-color 0.3s ease, transform 0.3s ease;
}

.button-primary:hover {
  background-color: #0056b3;
  transform: scale(1.05);
}
CSS for Card Hover Effect:
css

Copy
.card {
  background-color: #FFFFFF;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
  transition: transform 0.3s ease, box-shadow 0.3s ease;
}

.card:hover {
  transform: translateY(-5px);
  box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
}
Font Implementation:
css

Copy
body {
  font-family: 'Open Sans', sans-serif;
  color: #333333;
}

h1, h2, h3 {
  font-family: 'Montserrat', sans-serif;
  color: #1A1A1A;
}
Ensure fonts are loaded via Google Fonts or a CDN for crisp rendering.
5. Why This Design Works
Readability: High contrast ensures accessibility, with light backgrounds for body text and dark for headings, aligning with "Responsive Web Design | Best Practices For Accessibility | LevelAccess" ([Responsive Web Design | Best Practices For Accessibility | LevelAccess]([invalid url, do not cite])).
Engagement: Vibrant button colors and hover effects create interactivity, enhancing user feedback, as per "The Best Button Colors for Websites (Updated 2024) | Designerly" (The Best Button Colors for Websites (Updated 2024) | Designerly).
Modern Look: Glassmorphism and subtle shadows add depth, while smooth transitions ensure a fluid experience, matching trends from "Website Design Trends for 2025: Suggested Color Combinations and Fonts | ControlF5" (Website Design Trends for 2025: Suggested Color Combinations and Fonts | ControlF5).
Clean and Neat: Minimalistic design with white space and consistent typography ensures clarity, aligning with "Designer-approved website color schemes | Canva" (Designer-approved website color schemes | Canva).
4. Why This Approach Works
Clarity and Simplicity: Each navigation item is descriptive, following best practices from Best Practices for Clear and Simple E-Learning Navigation, ensuring users can find what they need quickly.
Role-Based Segmentation: Tailored navigation reduces clutter, as seen in Higher Ed Navigation Best Practices, enhancing user experience for diverse roles.
Real-Time Updates: WebSocket integration ensures navigation reflects current data, such as new bookings or session statuses, aligning with your emphasis on real-time functionality.
Premium UI/UX: Glassmorphism, animations, and responsive design (e.g., bottom nav on mobile) create a modern, Instagram-like feel, as requested, with minimal icons (Heroicons) for clarity.
This approach ensures PeerLearn is a "real-worth app," competing with platforms like Coursera and Skillshare, with a focus on usability and engagement.
Why This Matters: PeerLearn integrates real-time video, AI-driven features, secure payments, and a polished UI/UX. Its success hinges on seamless performance, advanced functionality, and a premium experience across all devices. Replit’s constraints demand precise execution.
 Master Prompt for Replit Core AI (No Code, Just Design)
"Design a premium, next-generation UI/UX layout for a modern EdTech application like PeerLearn. Requirements:

Theme: Ultra-premium, professional EdTech app with a premium membership feel.

Responsiveness: Perfectly responsive for both desktop and mobile views; adjust layout dynamically, stacking smartly on mobile.

Speed: Optimized for instant loading, lightweight components, zero performance lags.

Styling:

Use clean, elegant, and simple layouts with correct white spacing and air between elements.

Smooth transitions and fluid animations on every action (scroll, hover, click).

Use glassmorphism for key cards, subtle neon shadows, blur backgrounds.

Use high-quality modern fonts like Inter, Poppins, or SF Pro Display.

Visual Effects:

Button click waves, background light particle animations.

Horizontal card scrollers with momentum swipe feel.

Hover effects: Slight 3D pop on cards, dynamic depth shadows, tilt on mouse move.

Smooth page transitions (fade-slide or swipe animations when moving between pages).

Elements to Design:

Header (Logo + Navigation Menu + Auth Buttons)

Hero Section (Catchy text + Call to Action)

Learner & Mentor Registration Forms (Multi-step wizard)

Live Session Cards (Thumbnail image, Session Title, Mentor Name, Button to Join, Price INR)

Mentor Profile Cards (Avatar, Skills tags, Bio snippet, Book Session button)

Testimonials Carousel

Pricing Section (Monthly, Yearly toggle with animated transition)

Notification popups (toast style, sliding from top right)

Error Pages (beautiful 404/403)

Page Plan:

Landing Page

Registration Page

Login Page

Learner Dashboard

Mentor Dashboard

Live Session Join Page

Checkout Page (Payment)

Profile Settings Page

Design Style:

Neumorphism + Glassmorphism mix.

Subtle animated backgrounds with gradients (purple-blue, dark-light transitions).

Minimal icons (prefer Lucide or Heroicons).

Cards with gentle border radius (rounded-2xl), mild shadow, layered look.

Buttons and interactions to feel alive — glowing on hover, ripple on click.

Use vibrant illustrations or thematic PNGs/icons related to education, mentorship, technology.

Mobile Optimization:

Collapsible menus.

Bottom sticky navbars.

Scroll snapping for sections.

Transitions:

When clicking Register/Login, slide-left transition.

Dashboard tabs animate with fade + zoom effect.

Live session room opens with a "door opening" transition.

Special Requirements:

All interactions should feel "worth it" — show premium quality in micro-interactions.

All popups, modals, and toast notifications must be fully mobile-optimized.

Minimize code complexity; use well-planned layouts, no clutter.

All text/buttons/icons should be perfectly aligned and follow a tight design grid.

UI must have a "meaningful richness" without overwhelming the user.

Use rectangles/rounded rectangles for card shapes with subtle background gloss.

Advanced hover states for mentor and session cards (zoom thumbnail slightly, raise card depth).

Only output the design layout plan, element-by-element explanation, and page-by-page frame structure, without writing any HTML/CSS code yet. Focus on creative, high-quality UI and UX only.
Prioritize real-world mobile + web experience like best EdTech apps (Coursera, Skillshare, Masterclass) but even better.
No Lorem Ipsum: use meaningful, real educational-related example data for all text, labels, names, images, buttons.
Final goal: premium, highly impressive, ultra-smooth user experience across web and mobile, with clean minimalist beauty and lively high-end interactions.

"

✅ This prompt covers:

Layouts

Responsiveness

Animations

Card Design

Premium Feel

Modern Spacing

Fast Load Experience

3D Hover Effects

Meaningful Text/Images

Smooth Page Transitions

Neat User Flow

Advanced Effects

Would you also like me to prepare a second even more specialized prompt just for Live Session Card design (like Netflix thumbnails, with all hover animations)? 🚀
It'll be crazy premium!
Shall I? 🎯✨






You said:
yes all each and evrythjing all 


ChatGPT said:
Perfect! 🔥
You want everything fully complete:

Main Master Prompt (done ✅ — already given)

Now let's also create specialized Master Prompts for each core part like:

Live Session Card (Netflix style)

Mentor Profile Card

Popups/Toasts

Animations & Transitions

Mobile Optimization

Premium Loading Animation

Complete Page-by-Page Design Instructions

Error-Free & Fast UX Instructions

Future Extensibility Tips (new features easily addable)

🎯 1. Master Prompt for Live Session Cards (Netflix / EdTech Style)
"Design an ultra-premium Live Session Card UI component for an EdTech app. Requirements:

Shape: Wide rectangle, smooth glass effect, slightly curved (rounded-xl).

Content:

Thumbnail Image (Session Banner)

Title of Live Session

Mentor Profile Pic + Name

Price in INR (with Rupee ₹ symbol)

'Join Now' Button (hover glow)

Hover Effects:

Card lifts upward slightly (3D effect)

Thumbnail zooms gently

Mentor Name and Title glow slightly

Layout:

Left: Thumbnail (50%)

Right: Session Details stacked nicely

Responsiveness:

Stack vertically in mobile view.

Maintain readable font size and tap-friendly buttons.

Transitions:

Hover reveal additional session details (topic overview on hover).

Visuals:

Use premium thumbnails related to education (vector graphics, classrooms, coding, etc.).

Style:

Mix Glassmorphism (card), slight Neumorphism (buttons), and subtle motion particles in background."

🎯 2. Master Prompt for Mentor Profile Cards
"Design a modern, attractive Mentor Profile Card for a learning platform. Requirements:

Card Shape: Rectangle, glass effect, with soft edge blur.

Content:

Mentor Profile Picture (circle)

Mentor Name

Domain / Specialization Tags

Short Bio Snippet (max 3 lines)

'Book Session' Button

Hover Effects:

Slight tilt or 3D pop on hover

Glow around profile picture

Buttons animate on hover (color transition or gentle pulse)

Responsiveness:

Profile picture and content stack vertically on small screens.

Design Details:

Light background with minimalistic tag design.

Clean readable fonts.

Transitions:

Smooth appearance of extended bio on hover."

🎯 3. Master Prompt for Premium Popups/Toasts (Notifications)
"Create premium, smooth, beautiful popups/toasts for app notifications. Requirements:

Position: Top-right or bottom-center

Appearance:

Slide in with fade effect

Slight shadow under toast

Rounded corners

Subtle background blur

Contents:

Icon + Title

Small text (1-2 lines)

Animation:

Toasts should auto-disappear after 3-5 seconds.

Manual close button (small 'x' in corner)

Mobile Adaptation:

Full-width banner-style notification on mobile."

🎯 4. Master Prompt for Animations & Page Transitions
"Design fluid, high-quality page transitions and element animations for an EdTech app. Requirements:

On page load:

Elements fade-in with staggered delays.

On page change:

Slide-left, fade-left transitions.

Scroll Effects:

Horizontal scroll snapping for card carousels.

Parallax background movement.

Hover Effects:

Buttons glow slightly.

Cards lift gently.

Loading Screens:

Show branded loading animation on slow network (branded loader GIF or SVG)."

🎯 5. Master Prompt for Mobile Optimization
"Ensure mobile-friendly UI design for all app elements. Requirements:

Stack columns vertically when screen width < 768px.

Use big touch-friendly buttons.

Minimize unnecessary text.

Bottom sticky navigation for main pages.

Mobile-specific animations: shorter, lighter."

🎯 6. Master Prompt for Premium Loading Animations
"Create a branded, meaningful loading animation. Requirements:

Show when app is fetching data or switching pages.

Loader must match PeerLearn brand: books flying, learning light bulb, smooth circle progress.

Smooth fading of loader when data is ready.

No flicker or jank on fast internet connections.

Use background music chime (optional) if loading >5 sec."

🎯 7. Master Prompt for Full Page-by-Page Layout and Frames
"Define complete frame-by-frame UI/UX design for an EdTech app (PeerLearn). Pages to include:

Landing Page (Logo + Title + Quote + Register/Login Buttons)

Registration Flow (Step 1: Role Selection -> Step 2: Details Form -> Step 3: Success Page)

Login Page (Simple Login form + Forgot Password)

Learner Dashboard (Welcome Banner + Your Courses + Suggested Mentors)

Mentor Dashboard (Upcoming Sessions + Bookings + Earnings Panel)

Live Session Join Page (Live Video Screen + Chat + Participant List)

Checkout Page (Session Details + Payment Integration)

Profile Settings Page (Editable Profile Details + Interests)

404 / 403 Pages (Beautifully designed error screens)

Each page should follow the premium design principles mentioned: glassmorphism, clean layouts, professional fonts, smart color palettes, perfect spacing."

🎯 8. Master Prompt for Error-Free, Fast UX
"Implement smooth, error-free user experience:

All forms have validation + error messages

Fast transitions; preload major assets.

Always provide visual feedback on button clicks (loading spinners inside button if waiting).

Use Retry if API call fails (with smart popup).

Secure all user authentication flows."

🎯 9. Master Prompt for Future Features Extensibility
"Design with future extensibility:

Components should be modular (card component, modal component, button component).

Easy to add:

New Learning Categories

New Mentor Types

Live Session Types (Group, Private)

Clarifications on Requirements
Frontend Technology:
The prompt oscillates between Django templates only and React. The strict constraints (e.g., “No React, Vue, or other frameworks—rely on Django templates”) and the absence of React in the required libraries list confirm that Django templates with Tailwind CSS via CDN is the intended approach. I’ll ignore React references (e.g., simple-peer, framer-motion) and use vanilla JavaScript within templates for WebRTC and animations, supplemented by Tailwind’s utility classes and Lottie animations for premium effects.
Resolution: All UI will be built using Django templates (*.html), styled with Tailwind CSS (<script src="https://cdn.tailwindcss.com"></script>), and enhanced with JavaScript for WebRTC (RTCPeerConnection, MediaRecorder) and Lottie animations (<script src="https://cdnjs.cloudflare.com/ajax/libs/lottie-web/5.12.2/lottie.min.js"></script>).
Total Pages:
The prompt lists 13 distinct pages/modals:
Landing Page (/)
Login Page (/login/)
Learner Registration (4-step wizard, /register/learner/)
Mentor Registration (4-step wizard, /register/mentor/)
Learner Dashboard (/dashboard/learner/)
Mentor Dashboard (/dashboard/mentor/)
Session Detail & Booking Modal
Cart & Checkout (/cart/)
Live Session Room (/session/<room_id>/)
Feedback Modal
Profile & Settings (/profile/)
Admin Panel (/admin/)
Error Pages (401, 403, 404, 500)
Note: The Registration pages (Learner and Mentor) are multi-step but treated as single logical pages with distinct steps, each rendered as a separate template view (e.g., register_learner_step1.html, register_learner_step2.html).
Real-Time Video Session as Main Feature:
The live video session is the cornerstone of PeerLearn, requiring WebRTC for peer-to-peer streaming, Django Channels for signaling, and Zoom-like features (screen sharing, whiteboard, raise hand, recording, sound notifications).
Implementation: Uses RTCPeerConnection with Google STUN servers (stun:stun.l.google.com:19302), a TURN server stub, and MediaRecorder for recordings. Features are synchronized via WebSocket messages, with recordings stored in /media/recordings/ and linked to the Recording model in SQLite3.
Optimization: H.264 codec, adaptive bitrate, and reconnection logic (3 retries) ensure no delays or buffering, even on low bandwidth.
Storage and Server Management:
Video Storage: Recordings are saved as MP4 files in /media/recordings/ on the server, with metadata (session ID, timestamp) stored in the Recording model. Files are accessible via secure, authenticated endpoints (/api/recordings/<id>/).
Server: Django’s ASGI server (Daphne) handles WebSocket signaling, with Redis (channels-redis) for channel layers to support concurrent sessions. Replit’s environment is configured to handle multiple users via .replit and run.sh.
Scalability: Modular Django apps and Docker-ready setup (Dockerfile, docker-compose.yml) prepare for future scaling. SQLite3 is used initially, with environment variables (python-decouple) for PostgreSQL compatibility.
Database:
SQLite3: The only database used, configured in settings.py ('ENGINE': 'django.db.backends.sqlite3'). Models include CustomUser, Session, Recording, Booking, Notification, Leaderboard, and OfflineData.
Storage Usage: SQLite3 stores metadata (e.g., session details, user profiles). Video files are stored on the filesystem (/media/), not in the database, to optimize performance. Typical recording size: ~100MB/hour at 720p, requiring efficient disk management on Replit (monitor storage limits).
UI/UX and Gamification:
Premium Design: Glassmorphism (backdrop-filter: blur(12px)), Tailwind CSS, Poppins Bold (24–32px) for headlines, Inter Regular (14–16px) for body. Colors: Orange (#FF5734), Purple (#BE94F5), Yellow (#FCCC42), Light Gray (#F7F7F5), Dark Text (#151515).
Animations: Hover lift (transform: translateY(-4px)), button pulse (@keyframes pulse), slide transitions (transform: translateX(100%)), Lottie animations (e.g., “rocket launch”, “checkmark”).
Gamification: Progress bars, badges with unlock animations, confetti (Lottie), real-time leaderboards updated via WebSocket.
Responsiveness: Desktop (fixed layouts), tablet (2-column grids), mobile (bottom nav, swipeable carousels, sticky buttons).
Replit Deployment:
Replit is the deployment platform, using a Python repl with .replit (run = "bash run.sh") and run.sh to install dependencies, run migrations, and start the server (daphne peerlearn.asgi:application -b 0.0.0.0 -p 8000).
Constraints: Replit’s limited storage (~1GB free tier) requires efficient video storage management (e.g., pruning old recordings). Redis is hosted in-memory or via an external service (e.g., Replit’s Redis add-on if available).
Advanced Features:
Screen Sharing: Uses getDisplayMedia to stream the user’s screen, synced via WebSocket.
Whiteboard: HTML5 <canvas> element, with drawing strokes sent over WebSocket for real-time collaboration.
Raise Hand: Button sends a WebSocket message, displaying a badge in the mentor’s UI.
Recording: MediaRecorder captures video/audio, saving to /media/recordings/.
Sound Notifications: Audio files (e.g., join.mp3) played via JavaScript on WebSocket events (user join/leave).
AI Transcription: Gemini API (google-cloud-aiplatform) processes audio streams for real-time transcription, stored in the Transcript model and displayed in the session room’s sidebar.
Offline Mode:
Uses django-offline to cache data locally (e.g., session details, bookings) in the browser’s localStorage or IndexedDB. Syncs with the server when online via WebSocket (ws://.../ws/offline_sync/).
Multi-Language Support:
Implemented with django-i18n, supporting English and Spanish. Templates use {% trans %} tags, and models include translated fields (e.g., session titles).
Total Pages and Display Details
Total Pages: 13 (including modals and error pages). Each page is designed to be responsive across desktop, tablet, and mobile, with premium UI/UX, glassmorphism, and gamified elements. Below is a detailed breakdown of each page’s layout, content, container sizes, and how users view/interact with them.

1. Landing Page (/)
Purpose: Attract visitors, showcase sessions/mentors, drive registration/login.
Layout:
Desktop:
Top Nav: Fixed, 100% width, 80px height, bg-white/80 backdrop-blur-md (glassmorphism), border-b (border-gray-200).
Hero: Full-width, 600px height, gradient background (bg-gradient-to-r from-orange-500 to-purple-500).
Main Content: Centered, 1200px max-width, grid layout.
Footer: 100% width, 200px height, bg-gray-900 text-white.
Mobile:
Hamburger menu (top-right, 40x40px) toggles sidebar (translate-x-0 animation).
Hero stacks vertically, 400px height.
Content in single-column, swipeable carousels.
Content & Containers:
Top Nav:
Logo (left, 150x50px, PNG).
Links: “Live Sessions”, “Mentors”, “About”, “Support” (16px, text-gray-800 hover:text-orange-500).
CTAs: “Login” (outline button, border-orange-500), “Register” (solid button, bg-orange-500 text-white).
Interactions: Links underline on hover, buttons pulse (@keyframes pulse).
Hero:
Left: H1 (“Learn 1:1 with Top Mentors”, 32px, Poppins Bold).
Right: Lottie animation (“rocket launch”, 300x300px).
CTA: “Get Started” (200x50px, bg-orange-500 hover:bg-orange-600, pulse animation).
Animation: Text fades in (opacity-0 to opacity-100, 0.5s), rocket slides up (translateY(20px) to 0).
Featured Sessions:
Carousel, 4 cards (300x400px, bg-white/60 backdrop-blur-md shadow-lg rounded-xl).
Card: Thumbnail (300x200px), Title (16px), Mentor (14px), “Book” button (150x40px, bg-orange-500).
Interactions: Card lifts on hover (translateY(-4px)), button glows (box-shadow).
Mobile: Swipeable, 1 card visible.
Top Mentors:
3x2 grid, cards (350x250px, border-gray-200 rounded-lg).
Card: Avatar (100x100px), Name, Expertise, “Follow” button (bg-purple-500).
Interactions: Avatar scales (scale(1.1)), button pulses.
Testimonials:
3 cards (400x200px, bg-purple-100 rounded-lg).
Text (14px), Star Rating (5 yellow stars), User Name.
Animation: Cards slide in on scroll (translateX(100%) to 0).
Footer:
Links: “Privacy”, “Terms”, “Contact” (14px).
Social Icons (40x40px, hover:text-orange-500).
Transitions:
Page load: Hero fades in (0.5s), carousel slides from right (translateX(100%)).
Button click: Ripple effect (background-color transition, 0.3s).
Nav toggle (mobile): Sidebar slides in from left (translateX(-100%) to 0).
Loader: Lottie “rocket launch” (200x200px), centered during API calls.
Responsive Behavior:
Tablet: 2-column mentor grid, hero text 24px.
Mobile: Single-column, hamburger menu, hero button full-width.
User View:
Visitors see the page without login, scrolling through carousels and testimonials.
Clicking “Login” or “Register” redirects to respective pages.
Clicking “Book” on a session prompts login (/login/?next=/session/<id>/).
Backend:
View: views.landing renders landing.html.
Data: Session.objects.filter(is_featured=True) for carousel, CustomUser.objects.filter(role='mentor', is_featured=True) for mentors.
2. Login Page (/login/)
Purpose: Authenticate users with email/password or social login.
Layout:
Desktop: Centered card (400x600px, bg-white/80 backdrop-blur-md rounded-xl shadow-lg).
Mobile: Full-width card, 16px padding, sticky “Login” button.
Content & Containers:
Header: Logo (150x50px), “Welcome Back!” (H1, 24px, Poppins Bold).
Illustration: unDraw “unlocking door” (200x200px, centered).
Form (300x300px, border-gray-200 rounded-lg):
Email Input (100% width, 48px height, border-gray-300 focus:border-orange-500).
Password Input (with eye-toggle, same size).
Interactions: Input border glows orange on focus (box-shadow).
Error: Inline “Invalid credentials” (red, 12px).
Login Button: 200x50px, bg-orange-500 hover:bg-orange-600, pulse animation.
Social Login: “Login with Google/Facebook” (2 buttons, 150x40px, border-gray-300 hover:bg-gray-100).
Link: “Don’t have an account? Sign Up” (14px, text-orange-500 hover:underline).
Transitions:
Page load: Card fades in (opacity-0 to 1, 0.5s), illustration slides up (translateY(20px) to 0).
Form submit: Button ripples (background transition), loader appears if delayed.
Loader: Lottie “spinning globe” (150x150px) during authentication.
Responsive Behavior:
Tablet: Card 350px wide.
Mobile: Form full-width, buttons stack vertically.
User View:
Users enter email/password and click “Login” or use social login buttons.
On success, redirected to /dashboard/<role>/.
On failure, inline error displays without page reload (AJAX via JavaScript).
Backend:
View: users.views.login_view handles POST /api/login/.
Allauth: Configured for email and social (Google/Facebook) login.
3. Learner Registration (/register/learner/, 4 Steps)
Purpose: Onboard learners with a gamified, multi-step form.
Layout:
Desktop: Centered card (500x700px, bg-white/80 backdrop-blur-md rounded-xl).
Mobile: Full-screen, sticky “Next” button at bottom.
Content & Containers (Per Step):
Progress Bar: Top, 100% width, 10px height, bg-gray-200 with bg-orange-500 fill (25% per step).
Step 1: Basic Info:
Illustration: “Waving hand” (200x200px).
Fields (300x48px, border-gray-300 focus:border-orange-500): Full Name, Email, Password, Confirm Password.
Validation: Real-time email check (/api/check_email/), password strength bar (JavaScript).
Gamification: Tooltip “Complete Step 1 to unlock badge!” (12px, bg-yellow-100).
Button: “Next” (200x50px, bg-orange-500).
Step 2: Interests:
Illustration: “Map & Pin” (200x200px).
Tag Input (300x100px, border-gray-300), Gemini API suggestions (5 chips, bg-purple-100 hover:bg-purple-200).
Error: “Select at least 1 tag” (red, 12px).
Button: “Next”.
Step 3: Career Goal:
Illustration: “Rocket launch” (200x200px).
Dropdown (300x48px, e.g., “ML Engineer”) + Free-text.
Tooltip: “Set a goal for better recommendations!” (12px).
Button: “Next”.
Step 4: Profile Picture:
Illustration: “Avatar placeholder” (200x200px).
Upload Button (200x50px, border-dashed border-gray-300).
Validation: JPEG/PNG, ≤2MB.
Button: “Finish” (triggers confetti animation).
Interactions: Upload button glows, card lifts on hover.
Transitions:
Step change: Slide left-to-right (translateX(100%) to 0, 0.5s), fields fade in.
Submit: Confetti (Lottie, 2s), redirect to /dashboard/learner/.
Loader: Lottie “loading dots” (100x100px) during API calls.
Responsive Behavior:
Mobile: Full-screen steps, progress dots instead of bar, sticky “Next” button.
User View:
Users progress through steps, clicking “Next” after filling fields.
Real-time validation (AJAX) prevents submission errors.
On completion, confetti celebrates, and auto-login redirects to the dashboard.
Backend:
View: users.views.register_learner uses session storage for partial data.
Model: CustomUser (role='learner', interests, career_goal).
API: POST /api/register/learner/.
4. Mentor Registration (/register/mentor/, 4 Steps)
Purpose: Onboard mentors with expertise and media.
Layout: Same as learner (500x700px card, mobile full-screen).
Content & Containers:
Progress Bar: Same as learner.
Step 1: Basic Info: Same as learner.
Step 2: Expertise & Skills:
Illustration: “Toolbox” (200x200px).
Two Tag Inputs (300x100px): Domain (e.g., “Python”), Skills.
Error: “Select at least 1 domain” (red, 12px).
Button: “Next”.
Step 3: Bio & Media:
Illustration: “Camera” (200x200px).
Bio Textarea (300x150px, 150–500 chars).
Profile Image Upload (200x50px, border-dashed).
Intro Video URL/Upload (300x48px).
Validation: Video ≤5MB, valid URL.
Button: “Next”.
Step 4: Availability:
Illustration: “Calendar” (200x200px).
Day/Time Slots (checkbox grid, 300x200px, optional).
Button: “Finish” (shows “Pending Approval” page).
Transitions:
Same slide and fade as learner.
Approval page: Fades in with Lottie “waiting” animation.
Loader: Lottie “waiting” (100x100px).
Responsive Behavior: Same as learner.
User View:
Similar to learner flow, with mentor-specific fields (expertise, media).
After submission, users see a “Pending Approval” page until admin approval.
Backend:
View: users.views.register_mentor.
Model: CustomUser (role='mentor', is_approved=False).
Admin approval updates is_approved=True, emails user via Celery.
5. Learner Dashboard (/dashboard/learner/)
Purpose: Browse, book, manage sessions, and track progress.
Layout:
Desktop: Sidebar (250px, fixed, bg-white/80 backdrop-blur-md) + Main Content (flex-1).
Mobile: Bottom nav (60px, bg-white shadow), content full-width.
Content & Containers:
Sidebar:
Links: “Live Sessions”, “Mentors”, “My Posts”, “My Bookings”, “Cart”, “Profile”, “Settings” (16px, hover:bg-orange-100).
Mobile: Bottom nav with icons (40x40px).
Header (100% width, 80px, bg-white shadow):
Search Bar (300x40px, border-gray-300 focus:border-orange-500, Gemini API autocomplete).
Notifications Bell (40x40px, hover:text-orange-500).
Profile Dropdown (150x40px, bg-gray-100 rounded-lg).
Interactions: Bell pulses, dropdown expands (scale animation).
Main Content (1200px max-width, grid):
Progress & Achievements (600x200px, bg-white/60 backdrop-blur-md rounded-xl):
Progress Ring (100x100px, SVG, animates on load).
Badges (4x 80x80px, border-gray-200 rounded-full, hover reveals criteria).
Animation: Ring fills (stroke-dashoffset), badges slide in.
Recommended Sessions (600x400px, carousel):
Cards (300x400px, bg-white/80 backdrop-blur-md shadow-lg).
Filters: Free/Paid, Time, Price (dropdowns, 150x40px).
Interactions: Card lifts, “Book” button pulses.
Browse Mentors (600x300px, grid):
Mentor Cards (200x250px, border-gray-200).
“Follow” Button (100x40px, bg-purple-500).
My Posts (600x300px, bg-white rounded-lg):
Form: Topic, Duration, Time (300x48px inputs).
Post List: Status (Open/Accepted, 300x100px cards).
WebSocket: Updates status in real-time (ws://.../ws/notifications/).
Cart & Bookings (600x400px):
Cart: Session list, “Checkout” button (200x50px, bg-orange-500).
Bookings: Upcoming/Past (300x150px cards, “Join”/Download).
Interactions: Buttons glow on hover.
Transitions:
Page load: Sections fade in sequentially (0.3s delay each).
Navigation: Content slides in from right (translateX(100%)).
Booking: Modal fades in, scales up (scale(0.9) to 1).
Loader: Lottie “spinning book” (150x150px) during API calls.
Responsive Behavior:
Tablet: 2-column grid, sidebar collapsible.
Mobile: Single-column, bottom nav, swipeable carousels.
User View:
Users browse sessions, click “Book” to open a modal, or post session requests.
Real-time notifications (bell icon) update via WebSocket.
Clicking “Join” (active 10 min before) redirects to the session room.
Backend:
View: users.views.learner_dashboard.
Data: Session.objects.filter(is_active=True) for recommendations, Booking.objects.filter(user=request.user) for bookings.
WebSocket: ws://.../ws/notifications/ for updates.
6. Mentor Dashboard (/dashboard/mentor/)
Purpose: Manage sessions, respond to requests, track analytics.
Layout: Same as learner (sidebar + main content).
Content & Containers:
Sidebar: Links: “Dashboard”, “Create Session”, “Requests”, “My Sessions”, “Analytics”, “Earnings”, “Profile”.
Header: Same as learner.
Main Content:
Quick Stats (600x150px, bg-white/60 backdrop-blur-md):
4 Cards (150x100px): Upcoming, Pending, Earnings, Badges.
Interactions: Cards lift, stats animate up (countUp.js).
Top Learners (600x200px, carousel):
Avatar Cards (100x100px, border-gray-200 rounded-full).
Click: Opens profile popup (300x400px, bg-white shadow-lg).
Streak & Badges (600x150px):
Streak: “10-day teaching streak” (16px, bg-orange-100 rounded-lg).
Badges: 4x 80x80px, hover reveals criteria.
Upcoming Sessions (600x400px, carousel):
Cards (300x200px, bg-white/80 backdrop-blur-md).
“Join” Button (150x40px, bg-orange-500, pulses in join window).
Performance Chart (600x300px, bg-white rounded-lg):
Chart.js line chart (500x200px, sessions/month).
Interactions: Tooltips on hover.
Quick Actions (600x100px):
Buttons: “Create Session”, “Respond to Requests” (150x40px, bg-purple-500).
Recent Feedback (600x200px):
Cards (300x100px, bg-purple-100): Stars, Comment, Learner.
Transitions: Same as learner dashboard.
Loader: Lottie “spinning book” (150x150px).
Responsive Behavior: Same as learner.
User View:
Mentors create sessions, respond to learner posts, or join upcoming sessions.
Analytics charts visualize performance, updated via WebSocket.
Backend:
View: users.views.mentor_dashboard.
Data: Session.objects.filter(mentor=request.user), Booking.objects.filter(session__mentor=request.user).
WebSocket: Real-time updates for requests and bookings.
7. Session Detail & Booking Modal
Purpose: Display session details and handle booking.
Layout: Modal (600x800px, bg-white/80 backdrop-blur-md rounded-xl, centered).
Content & Containers:
Header: Session Title (24px), Close Button (40x40px, hover:bg-gray-100).
Content (560x700px):
Thumbnail (560x300px).
Description (16px, 500x200px).
Tags (chips, bg-purple-100).
Free/Paid Badge (100x40px, bg-green-500 or bg-orange-500).
Date/Time Picker (300x48px).
Interactions: Picker glows, badge pulses.
Buttons:
Free: “Confirm Booking” (200x50px, bg-orange-500).
Paid: “Add to Cart” (200x50px, bg-purple-500).
Animation: Ripple on click.
Transitions:
Modal: Scales up and fades in (0.3s).
Close: Fades out, scales down.
Loader: Lottie “loading book” during booking API call.
Responsive Behavior:
Mobile: Full-screen modal, sticky buttons.
User View:
Users view session details, select a time, and book (free) or add to cart (paid).
On success, a toast notification confirms the action.
Backend:
View: video.views.session_detail.
API: POST /api/book/ (free), POST /api/cart/add/ (paid).
8. Cart & Checkout (/cart/)
Purpose: Review and pay for sessions.
Layout: Centered card (800x600px, bg-white rounded-xl).
Content & Containers:
Session List (760x400px, border-gray-200):
Cards (760x100px): Title, Mentor, Price, “Remove” button.
Interactions: Card lifts, remove button turns red (bg-red-500).
Total (760x100px): Price (24px, text-orange-500).
Checkout Button: 200x50px, bg-orange-500, triggers Razorpay.
Transitions:
Page load: Cards slide in (translateY(20px) to 0).
Checkout: Razorpay modal fades in.
Loader: Lottie “payment processing” (150x150px).
Responsive Behavior:
Mobile: Full-width, vertical stack.
User View:
Users review sessions, remove items, and click “Checkout” to initiate Razorpay payment.
On success, redirected to a confirmation page.
Backend:
View: payments.views.cart.
API: POST /api/create_order/ (Razorpay), POST /api/verify_payment/.
9. Live Session Room (/session/<room_id>/)
Purpose: Host real-time video with advanced features.
Layout:
Desktop: Video Area (70%, 800x600px) + Sidebar (30%, 400x600px, bg-white/60 backdrop-blur-md).
Mobile: Full-width video, sidebar as swipe-up bottom sheet.
Content & Containers:
Top Bar (100% width, 60px, bg-white shadow):
Session Title (16px), Timer (16px, text-orange-500).
Buttons: Record, Mute All, Settings (40x40px, hover:bg-gray-100).
Video Area:
Mentor/Learner Videos (400x300px each, border-gray-200).
Controls: Mute, Camera, Share Screen, Whiteboard, Raise Hand (40x40px icons, hover:bg-orange-500).
Interactions: Controls glow, videos scale slightly on hover (scale(1.02)).
Sidebar:
Topic Analyzer: Progress bars (300x100px, Gemini API).
Agenda: List (300x200px, border-gray-200).
Action Items: Buttons (Next/Skip, 150x40px).
Chat: Textarea + Messages (300x200px).
Transcript Pane (bottom, 100% width, 200px, collapsible):
Text (14px), Download Button (150x40px).
Animation: Auto-scrolls, toggle fades.
Transitions:
Page load: Videos fade in, sidebar slides from right (translateX(100%)).
Leave: Feedback modal scales up.
Loader: Lottie “video loading” (200x200px) during WebRTC setup.
Responsive Behavior:
Mobile: Video full-width, controls dock bottom, sidebar swipe-up sheet.
User View:
Users join 10 min before, see video feeds, and use controls (mute, share, etc.).
Sidebar provides real-time transcription and agenda updates.
On session end, feedback modal appears.
Backend:
View: video.views.session_room.
WebSocket: ws://.../ws/video/<room_id>/ for signaling.
WebRTC: JavaScript in session_room.html uses simple-peer-like logic.
Recording: MediaRecorder saves to /media/recordings/.
10. Feedback Modal
Purpose: Collect session feedback.
Layout: Modal (400x300px, bg-white/80 backdrop-blur-md).
Content & Containers:
Header: “Rate This Session” (24px).
Stars: 5 icons (40x40px, hover:text-yellow-500).
Comment: Textarea (360x100px).
Submit Button: 200x50px, bg-orange-500.
Transitions: Scales up on open, fades out on submit.
Loader: Lottie “checkmark” on success.
Responsive Behavior: Full-screen on mobile.
User View:
Users rate (1–5 stars) and comment, then submit.
On success, a toast confirms submission.
Backend:
API: POST /api/feedback/.
11. Profile & Settings (/profile/)
Purpose: Edit user details and preferences.
Layout: Centered card (600x800px, bg-white rounded-xl).
Content & Containers:
Avatar: 100x100px, border-gray-200 rounded-full.
Form: Fields for Name, Interests, Bio, etc. (300x48px).
Toggles: Dark/Light Mode, Notifications (150x40px).
Save Button: 200x50px, bg-orange-500.
Transitions: Fields fade in, save ripples.
Loader: Lottie “saving” during submit.
Responsive Behavior: Full-width on mobile.
User View:
Users edit profile fields, toggle settings, and save changes.
Validation errors display inline.
Backend:
View: users.views.profile.
12. Admin Panel (/admin/)
Purpose: Manage users, sessions, and approvals.
Layout: Tailwind-styled Django admin.
Content & Containers:
Tables: Users, Sessions, Payments (100% width, border-gray-200).
Actions: Approve Mentor, Delete Session (150x40px buttons).
Transitions: Rows fade in.
Loader: Lottie “loading table”.
Responsive Behavior: Tables scroll horizontally on mobile.
User View:
Admins view and manage data, approving mentors or deleting sessions.
Backend:
Default Django admin, extended with custom actions.
13. Error Pages (401, 403, 404, 500)
Purpose: Handle errors gracefully.
Layout: Centered card (400x400px, bg-white/80 backdrop-blur-md).
Content & Containers:
Illustration: unDraw “error” (200x200px).
Message: e.g., “Page Not Found” (24px).
Button: “Back to Home” (200x50px, bg-orange-500).
Transitions: Card fades in.
Loader: None.
Responsive Behavior: Full-width on mobile.
User View:
Users see error details and click to return home.
Backend:
Views: views.error_404, etc.
End-to-End User Journeys (Workflows)
Below are the step-by-step user flows for all roles (Visitor, Learner, Mentor, Admin), detailing every page, click, form, and decision point. These flows cover the entire journey from landing to post-session feedback, including error handling and responsive behavior.

1. Visitor Flow
Landing Page (/):
View: Sees top nav (Live Sessions, Mentors, About, Support, Login, Register), hero with Lottie “rocket launch”, featured sessions carousel, top mentors grid, testimonials, and footer.
Actions:
Scrolls to explore sessions/mentors.
Clicks “Login” → Redirects to /login/.
Clicks “Register” → Redirects to /register/ (role selection).
Clicks “Book” on a session → Redirects to /login/?next=/session/<id>/ (prompts login).
Decisions:
Choose to login, register as learner, or register as mentor.
Browse sessions/mentors (requires login to interact).
Errors: None (public page).
Responsive:
Mobile: Hamburger menu toggles nav, hero stacks vertically, carousels swipeable.
Tablet: 2-column mentor grid.
2. Authentication
Login Page (/login/):
View: Centered card with logo, “Welcome Back!” H1, unDraw illustration, email/password inputs, social login buttons, and “Sign Up” link.
Actions:
Enters email/password, clicks “Login” → POST /api/login/ (AJAX).
Clicks “Login with Google/Facebook” → Initiates OAuth flow.
Clicks “Sign Up” → Redirects to /register/.
Decisions:
Login with credentials or social account.
Register if no account.
Errors:
Invalid credentials → Inline “Invalid credentials” (red, shake animation).
Server error → “Server error, try again” toast.
Outcomes:
Success → Redirects to /dashboard/<role>/ (learner or mentor).
Failure → Stays on page with error message.
Responsive:
Mobile: Full-width card, buttons stack vertically.
Tablet: Smaller card (350px).
Role Selection (/register/):
View: Two cards (“Learner”, “Mentor”) with flip animation on hover.
Actions:
Clicks “Learner” → Redirects to /register/learner/.
Clicks “Mentor” → Redirects to /register/mentor/.
Errors: None.
Responsive: Cards stack vertically on mobile.
3. Learner Registration (4-Step Wizard)
Step 1: Basic Info:
View: Card with progress bar (25%), “Waving hand” illustration, inputs for Full Name, Email, Password, Confirm Password.
Actions:
Fills fields, clicks “Next” → POST /api/register/learner/step1/ (stores in session).
Email input triggers real-time check (AJAX to /api/check_email/).
Errors:
Missing fields → Inline “Required” (red).
Email taken → “Email already registered”.
Password mismatch → “Passwords don’t match”.
Responsive: Sticky “Next” button on mobile.
Step 2: Interests:
View: Progress bar (50%), “Map & Pin” illustration, tag input with Gemini API suggestions.
Actions:
Types/selects tags (max 5), clicks “Next” → POST /api/register/learner/step2/.
Errors: “Select at least 1 tag” if empty.
Responsive: Suggestions wrap on mobile.
Step 3: Career Goal:
View: Progress bar (75%), “Rocket launch” illustration, dropdown + free-text input.
Actions:
Selects or types goal, clicks “Next” → POST /api/register/learner/step3/.
Errors: None (optional field), tooltip encourages completion.
Step 4: Profile Picture:
View: Progress bar (100%), “Avatar placeholder” illustration, upload button.
Actions:
Uploads image, clicks “Finish” → POST /api/register/learner/.
On success: Confetti animation, auto-login, redirect to /dashboard/learner/.
Errors: Invalid file (non-JPEG/PNG, >2MB) → “Invalid file format/size”.
Responsive: Full-screen on mobile.
Outcomes:
Successful registration creates CustomUser (role='learner'), logs user in, and shows “Welcome, [Name]!” with confetti.
Errors keep users on the current step with inline messages.
4. Mentor Registration (4-Step Wizard)
Step 1: Basic Info: Same as learner.
Step 2: Expertise & Skills:
View: Progress bar (50%), “Toolbox” illustration, two tag inputs (Domain, Skills).
Actions:
Selects tags, clicks “Next” → POST /api/register/mentor/step2/.
Errors: “Select at least 1 domain” if empty.
Step 3: Bio & Media:
View: Progress bar (75%), “Camera” illustration, textarea, image upload, video URL/upload.
Actions:
Fills bio, uploads media, clicks “Next” → POST /api/register/mentor/step3/.
Errors: Missing bio, invalid video (size >5MB, bad URL).
Step 4: Availability:
View: Progress bar (100%), “Calendar” illustration, checkbox grid for slots.
Actions:
Selects slots (optional), clicks “Finish” → POST /api/register/mentor/.
Redirects to “Pending Approval” page with Lottie “waiting”.
Errors: None (optional slots).
Outcomes:
Creates CustomUser (role='mentor', is_approved=False).
Admin approves via /admin/, triggering email (Celery) and redirect to /dashboard/mentor/.
5. Learner Dashboard (/dashboard/learner/)
View: Sidebar (or bottom nav on mobile), header with search/notifications, sections for Progress, Recommended Sessions, Mentors, Posts, Cart/Bookings.
Actions:
Search: Types query → Real-time suggestions (Gemini API), redirects to /search/ on enter.
Notifications: Clicks bell → Shows dropdown with booking updates, mentor responses (WebSocket).
Progress & Achievements: Views progress ring, hovers badges for criteria.
Recommended Sessions:
Filters by Free/Paid, Time, Price.
Clicks “Book” → Opens Session Detail modal.
Browse Mentors:
Clicks “Follow” → POST /api/follow/ (WebSocket notifies mentor).
My Posts:
Fills form (Topic, Duration, Time) → POST /api/learner/posts/.
Views post status (Open/Accepted) updated via WebSocket.
Cart & Bookings:
Adds paid sessions to cart from modal.
Clicks “Checkout” → Redirects to /cart/.
Clicks “Join” on upcoming bookings → Redirects to /session/<room_id>/.
Downloads recordings from past sessions (/api/recordings/<id>/).
Profile/Settings: Clicks dropdown → Redirects to /profile/.
Errors:
Slot conflict → “Mentor not available at this time”.
Network error → “Failed to load, retry” toast.
Responsive:
Mobile: Bottom nav, swipeable carousels, sticky search bar.
Tablet: Collapsible sidebar, 2-column grid.
Outcomes:
Books sessions, posts requests, or joins live sessions.
Real-time updates keep dashboard current.
6. Mentor Dashboard (/dashboard/mentor/)
View: Similar to learner, with sections for Stats, Top Learners, Streak/Badges, Sessions, Chart, Actions, Feedback.
Actions:
Create Session:
Fills form (Title, Description, Tags, Price, Schedule) → POST /api/sessions/.
Session goes live immediately.
Booking Requests:
Views learner posts, clicks “Respond” → Proposes time/rate → POST /api/mentor/respond/.
WebSocket notifies learner.
My Sessions:
Clicks “Join” → Redirects to /session/<room_id>/.
Edits/cancels sessions → POST /api/sessions/<id>/edit/ or /delete/.
Analytics: Views charts (Chart.js), hovers for tooltips.
Earnings: Requests payout → POST /api/mentor/withdraw/ (future Razorpay Payouts).
Feedback: Views ratings/comments, clicks to expand.
Errors:
Overlapping session → “You already have a session then”.
Cancellation too late → “Cannot cancel within 1 hour”.
Responsive: Same as learner.
Outcomes:
Creates/joins sessions, responds to requests, tracks performance.
7. Live Session Flow (/session/<room_id>/)
View: Video area (mentor/learner feeds), top bar (title, timer, controls), sidebar (analyzer, agenda, chat, transcript).
Actions:
Join: Clicks “Join” (active 10 min before) → Loads session room, connects WebSocket (ws://.../ws/video/<room_id>/).
Video Controls:
Clicks Mute/Unmute → Toggles getUserMedia audio.
Clicks Camera On/Off → Toggles video track.
Clicks Share Screen → Initiates getDisplayMedia, streams to peer.
Clicks Whiteboard → Shows <canvas>, syncs strokes via WebSocket.
Clicks Raise Hand (learner) → Sends WebSocket message, shows badge.
Clicks Record → Starts MediaRecorder, saves to /media/recordings/.
Sidebar:
Views Topic Analyzer (Gemini API progress bars).
Clicks Next/Skip on agenda items → Updates via WebSocket.
Sends chat messages → POST via WebSocket, displays instantly.
Toggles transcript auto-scroll, clicks “Download” → GET /api/transcript/<id>/.
Leave: Clicks “Leave” or session auto-ends → Shows Feedback modal.
Errors:
Media denied → Modal “Allow camera/mic, retry”.
Connection lost → “Reconnecting…” banner, retries 3 times.
Recording failure → “Recording unavailable, retry” toast.
Responsive:
Mobile: Full-width video, controls at bottom, sidebar as swipe-up sheet.
Tablet: Adjustable sidebar width.
Outcomes:
Completes session, provides feedback, downloads recording/transcript.
8. Feedback Modal
View: Modal with “Rate This Session” header, 5 stars, comment textarea, “Submit” button.
Actions:
Clicks stars to rate, types comment, clicks “Submit” → POST /api/feedback/.
On success: Toast “Thank you!”.
Errors: Submission failure → “Retry” toast.
Responsive: Full-screen on mobile.
Outcomes: Feedback saved, visible in mentor’s dashboard.
9. Admin Flow (/admin/)
View: Tailwind-styled Django admin with tables for users, sessions, payments, and actions.
Actions:
Clicks “Approve” on mentor → Updates is_approved=True, sends email (Celery).
Clicks “Delete” on session → Removes record, notifies users.
Errors: None (admin-only access).
Responsive: Tables scroll horizontally on mobile.
Outcomes: Manages platform data, approves mentors.
UI/UX Blueprint and Responsive Design
General Design Principles:

Glassmorphism: Cards and sidebars use backdrop-filter: blur(12px); background: rgba(255,255,255,0.6); for a frosted-glass effect.
Animations:
Hover: transform: translateY(-4px); transition: all 0.3s ease;.
Button Pulse: @keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.05); } }.
Slide Transitions: transform: translateX(100%); transition: transform 0.5s ease-in-out;.
Lottie Loaders: Centered, 150–200px, triggered during API calls.
Typography: Poppins Bold (24–32px) for headlines, Inter Regular (14–16px) for body.
Colors: Orange (#FF5734) for CTAs, Purple (#BE94F5) for accents, Yellow (#FCCC42) for highlights, Light Gray (#F7F7F5) for backgrounds, Dark Text (#151515).
Gamification:
Progress Bars: Fill animations on load (width: 0 to X%).
Badges: Unlock with Lottie confetti, hover to show criteria.
Leaderboards: Real-time updates via WebSocket, with rank animations.
Confetti: Lottie animation on registration completion, badge unlocks.
Responsive Behavior:

Desktop:
Fixed sidebars (250px), multi-column grids (1200px max-width).
Full layouts with visible nav, large video frames.
Tablet:
Collapsible sidebars (toggle via hamburger icon).
2-column grids for cards, smaller fonts (e.g., 20px headlines).
Video frames stack vertically or reduce to 600x400px.
Mobile:
Bottom nav (60px, icons only: Home, Sessions, Profile, etc.).
Swipeable carousels for sessions/mentors.
Full-screen forms with sticky buttons (e.g., “Next”, “Submit”).
Video occupies full width, controls dock at bottom, sidebar as swipe-up sheet.
Transitions:
Smooth resizing with Tailwind’s responsive classes (sm:, md:, lg:).
Mobile nav slides in/out (translateX).
Carousels use overflow-x-auto for swipe gestures.
Container Sizes:

Cards: 300x400px (sessions), 350x250px (mentors), 400x200px (testimonials).
Modals: 600x800px (session detail), 400x300px (feedback).
Video Frames: 400x300px (desktop), full-width (mobile).
Sidebar: 250px (desktop), 100% width as bottom sheet (mobile).
Nav: 80px (top), 60px (bottom on mobile).
Premium Transitions:

Page Load: Sections fade in sequentially (0.3s stagger using JavaScript setTimeout).
Modals: Scale up (scale(0.9) to 1) and fade in (0.3s).
Buttons: Ripple effect on click (CSS radial-gradient), pulse animation for CTAs.
Carousels: Slide left/right with transform: translateX, smooth easing (ease-in-out).
Gamification and Learning Platform Background
Gamification Elements:

Progress Bars/Rings: On learner dashboard, animate on load to show session completion (e.g., 78% filled, SVG stroke-dashoffset).
Badges: Unlock after milestones (e.g., 5 sessions, “Python Pro”). Displayed as circular cards (80x80px), greyed out if locked, colored with confetti on unlock.
Confetti: Lottie animation triggered on registration, badge unlocks, or session booking confirmation.
Leaderboards: Real-time ranking of users by sessions completed, updated via WebSocket (ws://.../ws/leaderboard/). Animated rank changes (e.g., “You moved to #3!”).
Streak Tracker: On mentor dashboard, shows teaching streaks (e.g., “10-day streak”) with fire emoji (🔥).
Tooltips: Gamified prompts (e.g., “Complete Step 1 to unlock badge!”) with yellow highlights (bg-yellow-100).
Learning Platform Background:

Background Style: Light gray (#F7F7F5) with subtle gradients (bg-gradient-to-br from-white to-gray-100) for depth. Hero sections use vibrant gradients (from-orange-500 to-purple-500).
Illustrations: unDraw SVGs (e.g., “unlocking door”, “rocket launch”) and Lottie animations (e.g., “checkmark”, “spinning book”) enhance engagement.
Video-Centric: Large video frames (800x600px desktop) dominate the session room, with minimal distractions. Dashboard thumbnails (300x200px) preview session content.
Interactive Elements:
Hover effects: Cards lift, buttons glow (box-shadow).
Click feedback: Ripple animations, subtle sound effects (e.g., “ping” for button clicks, sourced from free audio libraries).
Real-time updates: WebSocket-driven notifications (bell icon pulses), leaderboard ranks animate.
UI Elements:

Buttons: Rounded (rounded-lg), 150–200x40–50px, with bg-orange-500 (primary), bg-purple-500 (secondary), bg-gray-300 (neutral). Pulse animation for CTAs.
Inputs: 300x48px, border-gray-300 focus:border-orange-500, with glow effect on focus.
Cards: Glassmorphism (backdrop-blur-md), shadow-lg, 300–400px wide, with hover lift.
Icons: Heroicons (<svg> inline or via CDN), 40x40px, colored to match palette.
Loaders: Lottie animations (150–200px), centered, with specific themes (e.g., “rocket launch” for landing, “spinning book” for dashboard).
Advanced Functionality: Live Video Session
The live video session is PeerLearn’s core feature, designed to mimic Zoom with advanced capabilities. Below is a deep dive into its implementation, user interactions, and storage.

How It Works:

Access Control:
Only authenticated, booked users (learner or mentor) can join, verified via Session and Booking models.
View (video.views.session_room) checks request.user against booking status, returning 403 if unauthorized.
WebRTC Setup:
Template (session_room.html) loads JavaScript for WebRTC:
navigator.mediaDevices.getUserMedia accesses camera/mic.
RTCPeerConnection establishes peer-to-peer connection with STUN servers (stun:stun.l.google.com:19302).
WebSocket (ws://.../ws/video/<room_id>/) exchanges SDP offers/answers and ICE candidates.
TURN server stub included in peerConnection config for future scalability.
Features:
Screen Sharing: Button triggers getDisplayMedia, streams screen to peer, previewed in a thumbnail.
Whiteboard: <canvas> element captures drawing strokes, sent via WebSocket for real-time sync.
Raise Hand: Learner clicks button, sending WebSocket message to display a badge in mentor’s UI.
Recording: “Record” button starts MediaRecorder, saving MP4 to /media/recordings/.
Sound Notifications: JavaScript plays join.mp3/leave.mp3 on WebSocket events (user join/leave).
AI Transcription: Audio stream sent to Gemini API (google-cloud-aiplatform), transcribed in real-time, displayed in sidebar, and saved to Transcript model.
Optimization:
H.264 codec ensures efficient streaming.
Adaptive bitrate adjusts quality based on bandwidth (e.g., 720p to 480p).
Reconnection logic retries 3 times on ICE failure, showing “Reconnecting…” banner.
Storage:
Recordings saved as MP4 (~100MB/hour at 720p) in /media/recordings/.
Recording model stores metadata (session ID, file path, timestamp).
Transcripts saved as text in Transcript model, downloadable as .txt.
User Interactions:
Joins via “Join” button (active 10 min before).
Uses controls (mute, camera, share, etc.) with hover glow and click feedback.
Views sidebar for agenda, chat, and transcription.
Leaves session → Feedback modal appears.
Backend Workflow:

Routing: video/routing.py defines ws/video/<room_id>/.
Consumer: video/consumers.py handles WebSocket messages:
Joins room (group_add to room_<room_id>).
Exchanges SDP/ICE for WebRTC.
Broadcasts join/leave events for notifications.
Syncs whiteboard strokes, raise hand signals, and agenda updates.
View: video.views.session_room renders session_room.html, checks access.
Storage: Recording model links to /media/ files, served via authenticated endpoint.
Responsive Behavior:

Desktop: Side-by-side video frames, fixed sidebar.
Mobile: Full-width video, controls at bottom, sidebar as swipe-up sheet.
Tablet: Stacked videos, resizable sidebar.
Error Handling:

Media access denied → Modal with “Retry” button.
Connection loss → Reconnect attempts, then “Session ended” message.
Recording failure → Toast with retry option.
Storage and Database Details
Storage:

Video Recordings:
Stored in /media/recordings/ as MP4 files.
Size: ~100MB/hour at 720p (H.264, 30fps).
Naming: session_<room_id>_<timestamp>.mp4.
Access: Secure endpoint (/api/recordings/<id>/) requires authentication.
Management: Replit’s storage limits (~1GB free) require monitoring. Future: Implement pruning (delete recordings >30 days) or cloud storage (e.g., AWS S3).
Transcripts:
Stored in Transcript model as text fields.
Size: ~10KB/hour of text.
Downloadable as .txt via /api/transcript/<id>/.
Media Directory:
Configured in settings.py: MEDIA_ROOT = BASE_DIR / 'media', MEDIA_URL = '/media/'.
Protected by Django’s login_required decorator.
Database (SQLite3):

Models:
CustomUser: Fields for role, interests, bio, profile_picture, is_approved.
Session: Mentor, title, description, tags, price, schedule, is_active.
Recording: Session FK, file path, timestamp.
Booking: User, session, status (confirmed/pending).
Notification: User, message, timestamp.
Leaderboard: User, score (sessions completed), rank.
OfflineData: Cached data for offline mode (JSON).
Usage:
SQLite3 stores metadata, not video files, keeping the database lightweight (~1–10MB for 1000 users/sessions).
Indexes on Session.schedule, Booking.user for fast queries.
Migrations ensure schema updates (makemigrations, migrate).
Future Proofing:
psycopg2-binary installed for PostgreSQL compatibility.
Environment variable (DATABASE_URL) allows seamless switch (python-decouple).
Server Load:

Concurrent Sessions: Django Channels with Redis supports ~100 concurrent WebSocket connections on Replit’s free tier (limited by CPU/memory). Future: Scale with load balancers and external Redis.
Video Streaming: WebRTC is peer-to-peer, offloading bandwidth from the server. Signaling (WebSocket) uses minimal resources (~1KB/message).
Recording: Server-side MediaRecorder increases CPU/disk usage during recording. Optimize by limiting concurrent recordings (e.g., max 10).
Full-Stack Django Workflow (No Code)
Step-by-Step Workflow (aligned with prompt’s 11 steps, adapted to Django templates):

Initialize Replit Environment:
Create Python repl named “peerlearn”.
Add requirements.txt: django, djangorestframework, django-channels, channels-redis, django-allauth, razorpay, google-cloud-aiplatform, celery, redis, python-decouple, sentry-sdk, pytest, pytest-django, black, isort, flake8.
Run pip install -r requirements.txt.
Set Secrets: DJANGO_SECRET_KEY, RAZORPAY_KEY_ID, RAZORPAY_KEY_SECRET, GEMINI_API_KEY.
Create .replit: run = "bash run.sh".
Create run.sh: Install deps, migrate, start daphne peerlearn.asgi:application -b 0.0.0.0 -p 8000.
Run git init, add .gitignore (.env, db.sqlite3).
QA: Server starts, libraries installed, variables load.
Django Project Scaffolding:
Run django-admin startproject peerlearn ..
Create apps: python manage.py startapp users, video, payments, ai, search, notifications, leaderboard.
Update settings.py:
Add apps to INSTALLED_APPS.
Configure CHANNEL_LAYERS with Redis.
Set DATABASES to SQLite3.
Enable django-allauth, rest_framework, django-i18n, django-offline.
Set ASGI_APPLICATION = 'peerlearn.asgi.application'.
Create base.html with Tailwind CSS CDN, language switcher, and theme toggle.
QA: Server runs, templates render, Channels configured.
User Models & Authentication:
Define CustomUser in users/models.py: role, interests, bio, profile_picture, is_approved.
Set AUTH_USER_MODEL = 'users.CustomUser'.
Configure django-allauth for email/social login.
Build multi-step registration views/templates for learner/mentor.
Implement 2FA with email codes (Celery).
Set role-based redirects: learner to /dashboard/learner/, mentor to /dashboard/mentor/ or approval page.
QA: Registration/login work, redirects correct, only Django templates.
Database Models:
Define models in respective apps: Session, Recording, Booking, Notification, Leaderboard, OfflineData.
Run migrations (makemigrations, migrate).
Seed 10 sessions, 5 notifications, leaderboard entries (English/Spanish).
QA: Models work, seed data includes videos, multi-language fields render.
REST API Endpoints:
Create serializers/viewsets for sessions, recordings, bookings, notifications, leaderboard.
Add URLs with DRF router (urls.py).
Secure with token authentication (rest_framework.authentication.TokenAuthentication).
Add rate limiting (django-ratelimit).
QA: Endpoints return data, authentication enforced, rate limiting active.
WebSocket Signaling for Video:
Configure video/routing.py: ws/video/<room_id>/.
Create video/consumers.py: Handle SDP/ICE, notifications, leaderboard updates.
Use Redis channel layer (channels-redis).
QA: WebSocket connects instantly, no latency, authenticated users only.
WebRTC Video Setup:
Create session_room.html with video frames, controls, and sidebar.
Add JavaScript for WebRTC: getUserMedia, RTCPeerConnection, MediaRecorder.
Use STUN servers, stub TURN.
Optimize with H.264, adaptive bitrate.
QA: Video streams without delay, all features work, recordings save.
UI Framework & Premium Pages:
Style templates with Tailwind CSS, glassmorphism, and Lottie animations.
Implement dark/light mode (localStorage).
Build all pages as per UI blueprint (landing, dashboards, session room, etc.).
QA: UI responsive, theme toggle works, only Django templates.
Payment Integration:
Create views for Razorpay order creation (/api/create_order/) and verification (/api/verify_payment/).
Add cart.html with Razorpay.js checkout.
Implement offline payment stub (django-offline).
QA: Payments process, bookings update, offline confirmation works.
AI Recommendations & Search:
Implement Gemini API in ai/views.py for recommendations and transcription.
Create search.html with filters (language, domain).
QA: Recommendations match interests, search works, transcription updates.
Testing & Deployment:
Write pytest tests (90%+ coverage) for views, APIs, WebRTC, payments.
Test video performance under low bandwidth.
Configure .replit for continuous running.
Deploy on Replit, verify multi-language and offline mode.
QA: Tests pass, video performs, server runs continuously.
Actions and Clicks (Summarized)
Landing Page:

Clicks: Login, Register, Book (prompts login), Follow (mentors), carousel arrows.
Scrolls: Explore sessions, mentors, testimonials.
Login Page:

Clicks: Login button, Google/Facebook buttons, Sign Up link.
Inputs: Email, password.
Learner Registration:

Clicks: Next (each step), Finish, Back.
Inputs: Name, email, password, tags, career goal, image upload.
Mentor Registration:

Clicks: Next, Finish, Back.
Inputs: Name, email, password, domain/skills tags, bio, media uploads, slots.
Learner Dashboard:

Clicks: Search, notifications, Book, Follow, Post Request, Checkout, Join, Download.
Inputs: Search query, post form (topic, duration, time).
Mentor Dashboard:

Clicks: Create Session, Respond, Join, Edit/Cancel, Payout, View Feedback.
Inputs: Session form, response form (time, rate).
Session Detail Modal:

Clicks: Confirm Booking, Add to Cart, Close.
Inputs: Date/time picker.
Cart & Checkout:

Clicks: Remove, Checkout.
Razorpay: Payment inputs (card, UPI, etc.).
Live Session Room:

Clicks: Mute, Camera, Share Screen, Whiteboard, Raise Hand, Record, Chat Send, Next/Skip (agenda), Download Transcript, Leave.
Inputs: Chat messages.
Feedback Modal:

Clicks: Stars, Submit.
Inputs: Comment.
Profile & Settings:

Clicks: Save, toggles (theme, notifications).
Inputs: Name, interests, bio, etc.
Admin Panel:

Clicks: Approve, Delete, table filters.
Error Pages:

Clicks: Back to Home.
Conclusion
This response provides a comprehensive blueprint for PeerLearn, covering all 13 pages with detailed layouts, user workflows, UI/UX specifications, gamification, and advanced functionality (especially live video). The Django templates-only approach ensures compliance with the prompt, using Tailwind CSS, WebRTC, and SQLite3. Storage is efficiently managed with /media/ for videos and SQLite3 for metadata, while real-time features (video, notifications, leaderboards) leverage Django Channels and WebSocket.

Next Steps:

Begin with Step 1: Initialize Replit Environment as outlined.
After each step, verify with pytest tests, manual QA (desktop, tablet, mobile), and video performance checks.
Log progress (e.g., “Step 1 ✅”) and address any deviations immediately.
If you need further refinements or suspect deviations in Replit Core’s output, please share specific outputs (e.g., generated files, error logs), and I’ll adjust the prompt to enforce compliance. Let me know if you want to focus on a specific page or feature for deeper implementation details!







each dahbaord i thinki so much functinlty real time and pages ?depthly look and all workflow and actions and progress,performacr real graph and chart revenus,my leanirng,request,responses,cards,my sesions,mentors page,leaner posyt etc so many pages ?then total pages increase?working?logivc advance prmeium look and ui and ux ??ml autiacally display session related matching also powrerfull search  bar with firlter ?real worth app show 




Your query focuses on enhancing the PeerLearn EdTech platform, emphasizing the depth of functionality in the learner and mentor dashboards, real-time features, advanced UI/UX, comprehensive workflows, and additional pages for features like progress tracking, performance graphs, revenue, learning paths, session requests, responses, mentor pages, learner posts, and more. You’re concerned about whether the total number of pages increases with these additions, how the logic and workflows remain premium and functional, and how machine learning (ML) can automatically display relevant sessions. You also want a powerful search bar with filters and a real-worth app with a modern, premium look.

Drawing from our prior discussions (without repeating timestamps), you’ve consistently emphasized a premium, modern UI/UX inspired by platforms like Instagram and Facebook, real-time functionality via WebRTC and Django Channels, gamification, AI/ML personalization, and minimal-click workflows to compete with Udemy and Coursera. You’ve also highlighted issues like login redirects, slow loading, and complex forms, which I’ll address by ensuring streamlined navigation, optimized performance, and simplified interactions. Below, I’ll provide a detailed, depth-first analysis of the dashboards, additional pages, workflows, UI/UX, ML-driven session matching, search functionality, and how the app maintains a premium, scalable, and real-worth experience without compromising logic or functionality.

Addressing Your Query: Key Clarifications
Dashboards with Extensive Functionality:
You want learner and mentor dashboards to include real-time features like progress tracking, performance graphs, revenue (for mentors), learning paths, session requests/responses, cards for sessions/mentors, learner posts, and more.
Resolution: I’ll enhance the dashboards with these features, ensuring real-time updates via WebSocket, interactive charts (Chart.js), and gamified elements (progress bars, badges). Each section will be modular, responsive, and visually premium using glassmorphism and Lottie animations.
Total Pages and Potential Increase:
You’re concerned that adding features like mentor pages, learner posts, and analytics might increase the total number of pages beyond the current 13 (Landing, Login, Learner/Mentor Registration, Learner/Mentor Dashboard, Session Detail Modal, Cart, Live Session, Feedback Modal, Profile, Admin, Error Pages).
Resolution: Some features (e.g., progress, revenue, requests) can be integrated into existing dashboards as tabs or sections, avoiding new pages. However, distinct features like Mentors Page or Learner Posts may require dedicated pages, potentially increasing the total to 15–17 pages. I’ll detail these below and confirm their necessity.
Real-Time and Advanced Logic:
You want real-time updates (e.g., session status, notifications) and advanced logic for ML-driven session matching and powerful search with filters.
Resolution: Django Channels with Redis will power real-time updates. Gemini API (or a lightweight ML model like scikit-learn for Replit) will handle session recommendations based on user interests and history. The search bar will include filters (domain, price, time) and autocomplete via Gemini API.
Premium UI/UX:
You seek a modern, Instagram-like design with smooth animations, 3D effects, and a premium feel to ensure the app is “real-worth.”
Resolution: I’ll use Tailwind CSS (CDN), glassmorphism (backdrop-filter: blur(12px)), Lottie animations (e.g., confetti, loaders), and SVG illustrations (unDraw) for a polished, engaging UI. Interactions like hover lifts, ripple clicks, and slide transitions will enhance UX.
Workflows and Actions:
You want clear, minimal-click workflows for all actions (e.g., booking, posting, responding) and depth in functionality (e.g., charts, cards, requests).
Resolution: I’ll map out step-by-step workflows for each role, ensuring 2–3 clicks for key actions (e.g., book session, join session). Each dashboard section (e.g., My Learning, Revenue) will have interactive cards and real-time graphs.
Scalability and Working Logic:
You’re concerned about whether the app remains functional with added complexity.
Resolution: SQLite3 handles initial data efficiently, with indexes for fast queries. Redis ensures WebSocket scalability. Modular Django apps (users, video, payments, etc.) keep logic maintainable. Performance optimizations (e.g., caching, CDN) ensure fast loading (<300ms).
Real-Worth App:
You want PeerLearn to feel globally competitive, with features that drive user retention and trust.
Resolution: Gamification (badges, leaderboards), AI personalization, offline mode (django-offline), and multi-language support (English/Spanish via django-i18n) will make the app engaging and accessible. 2FA, HTTPS, and Razorpay ensure security and trust.
Total Pages: Current and Proposed Additions
Current Pages (13):

Landing Page (/)
Login Page (/login/)
Learner Registration (4-step, /register/learner/)
Mentor Registration (4-step, /register/mentor/)
Learner Dashboard (/dashboard/learner/)
Mentor Dashboard (/dashboard/mentor/)
Session Detail & Booking Modal
Cart & Checkout (/cart/)
Live Session Room (/session/<room_id>/)
Feedback Modal
Profile & Settings (/profile/)
Admin Panel (/admin/)
Error Pages (401, 403, 404, 500)
Proposed Additional Pages:
To accommodate your requested features (e.g., Mentors Page, Learner Posts, detailed analytics), I propose the following:

Mentors Page (/mentors/):
A dedicated page to browse all mentors, with filters (expertise, rating, availability) and cards (avatar, name, skills, “Follow” button).
Rationale: Enhances discoverability, aligning with your goal of a global mentorship platform. Avoids cluttering the dashboard.
Learner Posts Page (/posts/):
A page for learners to view and manage their session requests (e.g., “Need Python help, 1 hour, tomorrow”) and see mentor responses.
Rationale: Separates post management from the dashboard for clarity, especially with real-time updates.
Analytics Page (/analytics/) (optional):
A unified page for detailed graphs (progress, performance, revenue) for both learners and mentors, with exportable reports.
Rationale: If dashboard sections become too complex, this offloads analytics to a dedicated view. Alternatively, these can remain as dashboard tabs.
Total Pages After Additions:

Base Case: 13 (current) + 2 (Mentors, Learner Posts) = 15 pages.
With Analytics Page: 13 + 3 = 16 pages.
Decision: I’ll integrate analytics into dashboards as tabs (e.g., “Progress”, “Revenue”) to keep the total at 15 pages, unless you prefer a separate analytics page for depth. The Mentors and Learner Posts pages are essential for your requested functionality and user experience.
Working Logic:

Each page is a Django template (*.html), styled with Tailwind CSS and Lottie animations, ensuring consistency.
Django Channels handles real-time updates (e.g., post responses, session status).
REST APIs (/api/mentors/, /api/posts/) power dynamic data fetching.
SQLite3 stores data efficiently, with indexes on frequently queried fields (e.g., Session.mentor, Post.status).
Replit deployment is optimized with .replit and run.sh, supporting concurrent users via Daphne and Redis.
Enhanced Dashboards: Deep Dive
Below, I’ll detail the Learner and Mentor Dashboards, incorporating all requested features (progress, performance, revenue, learning paths, requests, responses, cards, sessions, mentors, posts) with real-time updates, charts, and premium UI/UX. Each section includes layout, content, actions, real-time logic, and responsive behavior.

1. Learner Dashboard (/dashboard/learner/)
Purpose: A central hub for learners to track progress, browse sessions, manage posts, book sessions, and view personalized recommendations.

Layout:

Desktop:
Sidebar (250px, fixed, bg-white/80 backdrop-blur-md): Links (Home, Sessions, Mentors, Posts, Bookings, Cart, Profile, Settings).
Header (100% width, 80px, bg-white shadow): Search bar, notifications bell, profile dropdown.
Main Content (1200px max-width, grid with tabs):
Tabs: “Overview”, “My Learning”, “Progress”, “Posts”, “Bookings”.
Grid: 2–3 columns, adjustable via drag (JavaScript).
Mobile:
Bottom Nav (60px, bg-white shadow): Icons for Home, Sessions, Mentors, Posts, Profile.
Header: Sticky, collapsible search bar.
Content: Single-column, swipeable carousels, tab bar at top.
Container Sizes:
Cards: 300x400px (sessions), 200x250px (mentors).
Charts: 600x300px.
Search Bar: 300x40px (expands to 100% on mobile).
Content & Functionality (by Tab):

Overview:
Recommended Sessions (carousel, 4 cards, bg-white/60 backdrop-blur-md):
Card: Thumbnail (300x200px), Title, Mentor, Price, “Book” button.
ML Matching: Gemini API analyzes user interests (CustomUser.interests) and history (Booking.objects) to suggest sessions (e.g., “Python for Beginners” if user likes coding).
Action: Click “Book” → Opens Session Detail modal.
Top Mentors (3x2 grid, 200x250px cards):
Avatar, Name, Expertise, “Follow” button (bg-purple-500).
Action: Click “Follow” → POST /api/follow/, WebSocket notifies mentor.
Quick Stats (4 cards, 150x100px):
Sessions Completed, Hours Learned, Badges Earned, Streak.
Animation: Numbers count up (countUp.js) on load.
Real-Time: WebSocket (ws://.../ws/notifications/) updates new recommendations, follows.
My Learning:
Learning Path (600x400px, bg-purple-100 rounded-lg):
Timeline (SVG, animated dots): Shows completed, current, and upcoming sessions.
ML-Driven: Suggests next steps (e.g., “Advanced Python” after “Python Basics”).
Action: Click session → Redirects to /session/<id>/ or booking modal.
Performance Graph (600x300px, Chart.js):
Line chart: Sessions completed vs. time (past 30 days).
Action: Hover for tooltips, click to filter by week/month.
Real-Time: Graph updates via WebSocket on session completion.
Progress:
Progress Ring (100x100px, SVG, stroke-dashoffset animation):
Shows % of learning goals completed (e.g., 78%).
Badges (4x 80x80px, border-gray-200 rounded-full):
Unlocked: Colored, Lottie confetti on hover.
Locked: Greyed out, tooltip shows criteria (e.g., “Complete 10 sessions”).
Leaderboard (300x200px, bg-white rounded-lg):
Top 5 learners by sessions completed, rank animates on change.
Action: Click rank → Shows user’s profile popup.
Real-Time: WebSocket (ws://.../ws/leaderboard/) updates ranks, badges.
Posts:
Create Post (300x200px form, border-gray-300):
Inputs: Topic (e.g., “Python help”), Duration, Preferred Time.
Action: Submit → POST /api/learner/posts/, WebSocket notifies mentors.
My Posts (carousel, 300x150px cards):
Status: Open, Accepted, Rejected.
Action: Click “View” → Shows mentor responses (time, rate, “Accept” button).
Real-Time: WebSocket updates post status, mentor responses.
Bookings:
Upcoming (carousel, 300x150px cards):
Session Title, Mentor, Time, “Join” button (active 10 min before).
Action: Click “Join” → Redirects to /session/<room_id>/.
Past (similar cards):
Includes “Download Recording” (/api/recordings/<id>/) and “View Feedback”.
Cart (300x200px, bg-white/80 backdrop-blur-md):
Lists paid sessions, “Checkout” button.
Action: Click “Checkout” → Redirects to /cart/.
Real-Time: WebSocket updates booking status, join availability.
Actions & Workflows:

Search: Type query → Gemini API suggests sessions/mentors, filters by domain, price, time (dropdowns, 150x40px). Enter → Redirects to /search/.
Book Session:
Click “Book” on session card → Opens modal.
Select time, click “Confirm” (free) or “Add to Cart” (paid).
For paid: Go to /cart/, click “Checkout” → Razorpay modal → Confirm payment → Booking confirmed.
Post Request:
Fill post form, submit → POST /api/learner/posts/.
Mentor responds (WebSocket notification) → View response, click “Accept” → Creates booking.
Join Session: Click “Join” (2 clicks from dashboard) → Redirects to live session room.
Track Progress: View ring, badges, or leaderboard; click badge → Shows criteria or unlocks confetti.
Real-Time Logic:

WebSocket: ws://.../ws/notifications/ pushes updates for bookings, posts, follows, leaderboards.
Redis: Stores channel layer for concurrent users (e.g., 100 simultaneous connections on Replit).
ML Matching: Gemini API processes CustomUser.interests, Booking.history, and session tags every 5 min (Celery task), updating recommendations.
UI/UX:

Glassmorphism: Cards and sidebar use backdrop-filter: blur(12px).
Animations:
Cards lift on hover (transform: translateY(-4px)).
Charts animate on load (Chart.js animate: true).
Lottie confetti for badge unlocks, session bookings.
Typography: Poppins Bold (24px) for headers, Inter Regular (14px) for body.
Colors: Orange (#FF5734) for CTAs, Purple (#BE94F5) for accents, Light Gray (#F7F7F5) for backgrounds.
Responsive:
Tablet: 2-column grid, collapsible sidebar.
Mobile: Bottom nav, swipeable carousels, sticky search bar.
Loader: Lottie “spinning book” (150x150px) during API calls.
Performance:

Caching: Redis caches session recommendations (5-min TTL).
Optimized Queries: Indexes on Session.tags, Booking.user.
CDN: Tailwind CSS and Lottie via CDN reduce load time (<300ms).
2. Mentor Dashboard (/dashboard/mentor/)
Purpose: Enable mentors to create sessions, respond to posts, track earnings, monitor performance, and manage learners.

Layout:

Desktop: Same as learner (sidebar, header, tabbed main content).
Mobile: Bottom nav, sticky header, single-column with swipeable sections.
Tabs: “Overview”, “Sessions”, “Requests”, “Analytics”, “Earnings”.
Content & Functionality (by Tab):

Overview:
Quick Stats (4 cards, 150x100px):
Upcoming Sessions, Pending Requests, Total Earnings, Badges.
Animation: Numbers count up on load.
Top Learners (carousel, 100x100px avatar cards):
Name, Sessions Taken, “Message” button.
Action: Click “Message” → Opens chat modal (300x400px).
Recent Feedback (300x200px, bg-purple-100):
Stars, Comment, Learner Name.
Real-Time: WebSocket updates stats, feedback.
Sessions:
Create Session (300x400px form, border-gray-300):
Inputs: Title, Description, Tags, Price, Schedule.
Action: Submit → POST /api/sessions/, goes live instantly.
My Sessions (carousel, 300x200px cards):
Title, Time, Status (Upcoming/Past), “Join” or “Edit/Cancel”.
Action: Click “Join” → Redirects to /session/<room_id>/.
Real-Time: WebSocket updates session status, bookings.
Requests:
Learner Posts (carousel, 300x150px cards):
Topic, Duration, Time, “Respond” button.
Action: Click “Respond” → Modal with time/rate inputs → POST /api/mentor/respond/, WebSocket notifies learner.
Real-Time: WebSocket pushes new posts, learner acceptances.
Analytics:
Performance Chart (600x300px, Chart.js):
Bar chart: Sessions taught vs. time (past 30 days).
Action: Filter by week/month, export as PDF (/api/export/analytics/).
Learner Engagement (600x200px):
Pie chart: % of learners by session type (e.g., Python, ML).
Streak & Badges (300x150px):
Streak: “10-day teaching streak” (bg-orange-100).
Badges: Unlocked with Lottie confetti.
Real-Time: Charts update via WebSocket on session completion.
Earnings:
Revenue Graph (600x300px, Chart.js):
Line chart: Earnings vs. time (past 30 days).
Action: Hover for session details, click to filter.
Payout Request (200x50px button, bg-orange-500):
Triggers Razorpay Payouts (stub for future).
Real-Time: WebSocket updates earnings on booking confirmation.
Actions & Workflows:

Create Session:
Fill form, submit → POST /api/sessions/.
Session appears in “My Sessions” and learner recommendations.
Respond to Post:
Click “Respond” → Modal opens.
Propose time/rate, submit → POST /api/mentor/respond/.
Learner accepts → Creates booking, WebSocket notifies both.
Join Session: Click “Join” → Redirects to live session room (2 clicks).
Track Earnings: View graph, request payout → POST /api/mentor/withdraw/.
Analyze Performance: Filter charts, export data for reports.
Real-Time Logic:

WebSocket: ws://.../ws/mentor/ updates sessions, requests, earnings.
ML Support: Gemini API suggests optimal session times based on learner demand (Celery task).
Redis: Caches analytics data for fast rendering.
UI/UX:

Same glassmorphism, animations, and typography as learner dashboard.
Unique Elements:
Revenue graph uses green (#34C759) for positive trends.
Payout button pulses when earnings exceed ₹1000.
Responsive:
Tablet: 2-column charts, collapsible sidebar.
Mobile: Swipeable sections, sticky payout button.
Performance:

Caching: Redis caches analytics queries.
Optimized Queries: Indexes on Session.mentor, Booking.session.
CDN: Chart.js and Lottie via CDN.
New Pages: Mentors and Learner Posts
1. Mentors Page (/mentors/)
Purpose: Browse and follow mentors, enhancing discoverability.

Layout:

Desktop: Header (80px), filter bar (100% width), 3x2 mentor grid (1200px max-width).
Mobile: Sticky filter bar, single-column grid, swipeable.
Content:

Filter Bar (300x40px inputs):
Expertise (dropdown, e.g., “Python”, “ML”).
Rating (slider, 1–5 stars).
Availability (checkboxes, e.g., “Next 24h”).
Action: Apply filters → GET /api/mentors/?expertise=Python&rating=4+.
Mentor Cards (350x250px, bg-white/80 backdrop-blur-md):
Avatar (100x100px), Name, Expertise, Rating, “Follow” or “View Profile” button.
Action: Click “Follow” → POST /api/follow/. Click “View Profile” → Modal with bio, sessions, video intro.
Load More (200x50px, bg-orange-500):
Fetches next 6 mentors via AJAX (/api/mentors/?page=2).
Real-Time: WebSocket updates mentor availability (e.g., “Online now” badge).

UI/UX:

Animations: Cards slide in on scroll (translateY(20px) to 0).
Responsive: Mobile uses swipeable carousel for filters.
Loader: Lottie “spinning globe” during API calls.
Workflow:

Visit /mentors/, apply filters.
Browse cards, click “Follow” or “View Profile”.
In profile modal, click “Book Session” → Redirects to booking modal.
Backend:

View: users.views.mentors.
API: GET /api/mentors/, POST /api/follow/.
Model: CustomUser (role='mentor').
2. Learner Posts Page (/posts/)
Purpose: Manage learner session requests and mentor responses.

Layout:

Desktop: Header, form (300x200px), post grid (2 columns).
Mobile: Sticky form at top, single-column grid.
Content:

Create Post Form:
Inputs: Topic, Duration, Time.
Action: Submit → POST /api/learner/posts/.
Post Cards (300x150px, bg-white/60 backdrop-blur-md):
Topic, Status (Open/Accepted), Mentor Responses (if any).
Action: Click “View Responses” → Modal with mentor offers (time, rate, “Accept” button).
Real-Time: WebSocket updates post status, new responses.
UI/UX:

Animations: Cards fade in, form pulses on focus.
Responsive: Mobile form collapses to icon until tapped.
Loader: Lottie “loading book” during submission.
Workflow:

Fill form, submit post.
View posts, click “View Responses” → Accept mentor offer → Creates booking.
WebSocket notifies mentor of acceptance.
Backend:

View: users.views.posts.
API: POST /api/learner/posts/, GET /api/posts/.
Model: Post (user, topic, duration, status).
Powerful Search Bar with Filters
Implementation:

Location: Header of dashboards, Mentors Page, and /search/ page.
Design:
Input: 300x40px, border-gray-300 focus:border-orange-500, placeholder “Search sessions or mentors…”.
Filters: Dropdowns (Domain, Price, Time, Language), appear on focus.
Mobile: Collapses to icon, expands full-width on tap.
Functionality:
Autocomplete: Gemini API suggests sessions/mentors as user types (e.g., “Py” → “Python Basics”).
Filters: Domain (e.g., “Coding”), Price (Free/Paid, range slider), Time (Next 24h, Week), Language (English/Spanish).
Action: Press Enter → Redirects to /search/?q=query&domain=Coding&price=free.
Real-Time: WebSocket updates search results if new sessions are added.
Backend:
View: search.views.search.
API: GET /api/search/?q=query&filters=....
Gemini API: Processes query for semantic matching.
UI/UX:

Animations: Suggestions fade in, filters slide down.
Loader: Lottie “searching” (100x100px) during API calls.
Responsive: Filters stack vertically on mobile.
Workflow:

Type query (e.g., “Python”) → See suggestions.
Apply filters (e.g., “Free”, “Next 24h”).
Press Enter → View results on /search/ (grid of session/mentor cards).
ML-Driven Session Matching
Implementation:

Logic:
Data Inputs: CustomUser.interests (e.g., [“Python”, “ML”]), Booking.history (past sessions), Session.tags.
Model: Gemini API (or scikit-learn’s TF-IDF for Replit) computes cosine similarity between user profile and session tags.
Frequency: Runs every 5 min via Celery, updates RecommendedSession model.
Display:
Learner Dashboard: “Recommended Sessions” carousel (4 cards).
Session Detail Modal: “Related Sessions” section (3 cards).
Accuracy:
Prioritizes sessions with matching tags (e.g., “Python” user sees Python sessions).
Weights recent bookings higher (e.g., completed “Python Basics” → suggests “Advanced Python”).
Real-Time: WebSocket pushes new recommendations if user updates interests.
Backend:

Task: ai.tasks.update_recommendations (Celery).
API: GET /api/recommendations/.
Model: RecommendedSession (user, session, score).
UI/UX:

Cards: Highlighted with “Recommended for You” badge (bg-yellow-500).
Animation: Cards slide in with glow effect (box-shadow).
Workflow:

User logs in → ML model fetches profile, computes recommendations.
Dashboard displays top 4 sessions, updates every 5 min.
User clicks “Book” → Proceeds to booking modal.
Premium UI/UX and Real-Worth App
UI Design:

Glassmorphism: Cards, sidebars, and modals use backdrop-filter: blur(12px) for a frosted-glass effect.
Animations:
Hover: Cards lift (translateY(-4px)), buttons pulse (@keyframes pulse).
Transitions: Pages slide in (translateX(100%) to 0), modals scale up (scale(0.9) to 1).
Lottie: Used for loaders (“spinning book”), celebrations (“confetti”), and illustrations (“rocket launch”).
Typography: Poppins Bold (24–32px) for headers, Inter Regular (14–16px) for body.
Colors: Orange (#FF5734), Purple (#BE94F5), Yellow (#FCCC42), Light Gray (#F7F7F5), Dark Text (#151515).
SVG Illustrations: unDraw for landing, modals (e.g., “unlocking door” for login).
3D Effects: Subtle shadows (shadow-lg), neumorphic buttons for premium feel.
UX Principles:

Minimal Clicks: Key actions (book, join, post) take 2–3 clicks.
Feedback: Ripple effects on buttons, toast notifications for success/errors.
Gamification:
Progress Rings: Animate on load, show % completion.
Badges: Unlock with confetti, greyed out if locked.
Leaderboards: Real-time rank animations, “You’re #3!” popups.
Accessibility: ARIA labels, keyboard navigation, high-contrast mode.
Real-Worth Features:

Engagement: Gamified badges, streaks, and leaderboards drive retention.
Personalization: ML recommendations tailor sessions to user needs.
Trust: 2FA (email codes), HTTPS, and Razorpay secure transactions.
Global Appeal: Multi-language (English/Spanish), offline mode (django-offline).
Scalability: Redis for WebSocket, SQLite3 for lightweight data, Docker-ready for future cloud deployment.
Performance:

Loading: <300ms with CDN (Tailwind, Lottie) and Redis caching.
Optimization: Lazy-loaded images, minified JS/CSS, indexed queries.
Replit: Daphne and Redis handle ~100 concurrent users, with pruning for storage limits (~1GB).
Comprehensive Workflows
Below are end-to-end workflows for key actions, ensuring minimal clicks, real-time updates, and error handling. These cover all roles and features you mentioned.

1. Learner Workflow
Browse and Book Session:
Log in → Redirect to /dashboard/learner/.
In “Overview” tab, see recommended sessions (ML-driven).
Click “Book” → Session Detail modal opens.
Select time, click “Confirm” (free) or “Add to Cart” (paid).
For paid: Go to /cart/, click “Checkout” → Razorpay modal → Pay → Booking confirmed (WebSocket notifies mentor).
Clicks: 2 (free) or 4 (paid).
Errors: Slot taken → “Choose another time”. Payment failure → “Retry” toast.
Post Session Request:
Go to “Posts” tab or /posts/.
Fill form (Topic, Duration, Time), submit → POST /api/learner/posts/.
WebSocket notifies mentors, updates post status.
Mentor responds → Notification (bell icon), click “View Responses” → Accept offer → Booking created.
Clicks: 3–4.
Errors: Invalid time → “Select future time”.
Join Session:
In “Bookings” tab, see upcoming session with “Join” button (active 10 min before).
Click “Join” → Redirects to /session/<room_id>/.
Clicks: 2.
Errors: Early join → “Join available at [time]”.
Track Progress:
Go to “Progress” tab, view ring, badges, leaderboard.
Hover badge → See criteria or unlock animation.
Click leaderboard rank → View profile popup.
Clicks: 1–2.
Real-Time: WebSocket updates ranks, badge unlocks.
2. Mentor Workflow
Create Session:
Go to “Sessions” tab, click “Create Session”.
Fill form, submit → POST /api/sessions/, session goes live.
WebSocket notifies learners in recommendations.
Clicks: 2.
Errors: Overlapping schedule → “You’re booked then”.
Respond to Post:
In “Requests” tab, see learner post, click “Respond”.
Modal opens, propose time/rate, submit → POST /api/mentor/respond/.
Learner accepts → WebSocket notifies mentor, creates booking.
Clicks: 3.
Errors: Invalid rate → “Enter positive value”.
Track Earnings:
Go to “Earnings” tab, view revenue graph.
Click “Request Payout” → POST /api/mentor/withdraw/.
Clicks: 2.
Real-Time: WebSocket updates earnings on bookings.
Analyze Performance:
Go to “Analytics” tab, view charts.
Filter by week/month, export PDF.
Clicks: 1–2.
Real-Time: WebSocket updates charts.
3. Admin Workflow
Approve Mentor:
Go to /admin/, view mentor table.
Click “Approve” → Updates is_approved=True, emails user (Celery).
Clicks: 2.
Errors: None (admin-only).
Manage Sessions:
View session table, click “Delete” → Removes session, notifies users.
Clicks: 2.
Ensuring a Real-Worth App
Competitive Edge:

Vs. Udemy/Coursera: PeerLearn offers live 1:1 mentorship, real-time collaboration (whiteboard, screen sharing), and gamified engagement, unlike pre-recorded courses.
Retention: Badges, streaks, and leaderboards encourage daily use. ML recommendations keep content relevant.
Trust: Secure payments (Razorpay), 2FA, and transparent mentor ratings build confidence.
Scalability:

SQLite3: Handles ~10,000 users initially, with indexes for speed.
Redis: Supports 100–1000 concurrent WebSocket connections.
Future: Dockerized setup (Dockerfile, docker-compose.yml) for AWS/GCP, PostgreSQL-ready (psycopg2-binary).
Testing and QA:

Pytest: 90%+ coverage for views, APIs, WebRTC, payments.
Manual Tests: Simulate 10 learners/mentors, verify real-time updates, video quality, and ML accuracy.
Performance: Test under low bandwidth (3G), ensure <300ms load times.
Replit Deployment:

Setup: .replit runs run.sh (daphne, migrations, Redis).
Storage: Monitor /media/recordings/ (~100MB/hour), prune old files.
Concurrency: Daphne handles ~50 simultaneous sessions, Redis scales WebSocket.
Final Page Count and Confirmation
Total Pages: 15:

Landing Page
Login Page
Learner Registration
Mentor Registration
Learner Dashboard
Mentor Dashboard
Session Detail Modal
Cart & Checkout
Live Session Room
Feedback Modal
Profile & Settings
Admin Panel
Error Pages
Mentors Page (new)
Learner Posts Page (new)
Rationale:

Analytics (progress, revenue, performance) are integrated into dashboard tabs to avoid a 16th page, keeping the app streamlined.
Mentors and Posts pages are critical for discoverability and request management, aligning with your global mentorship vision.
Working Confirmation:

Logic: Modular Django apps (users, video, ai) ensure maintainable code. REST APIs and WebSocket handle dynamic data.
Real-Time: Django Channels and Redis deliver instant updates (notifications, leaderboards, posts).
Premium UI/UX: Glassmorphism, Lottie animations, and 3D effects create a modern, Instagram-like experience.
ML and Search: Ge
Core Requirements
Real-Time Video: High-quality, low-latency streaming with WebRTC, optimized for no delays or buffering.
Advanced Features: Screen sharing, whiteboard, raise hand, recording, sound notifications, AI transcription, offline mode sync, leaderboards, multi-language support.
Storage & Server: Efficient video/audio storage, scalable for concurrent sessions.
Performance: No delays or buffering, adaptive under low bandwidth.
UI/UX: Premium, responsive, video-centric design with gamification (badges, progress bars, confetti, leaderboards).
Security: HTTPS, CSRF protection, CORS lockdown, rate limiting, two-factor authentication (2FA).
Scalability: Docker-ready, modular apps, future-proof for PostgreSQL and TURN servers.
Responsiveness: Fully optimized for web (desktop, tablet) and mobile devices with device-specific layouts.
Constraints
Use only Django, SQLite3, and specified libraries.
No React, Vue, or other frontend frameworks—rely on Django templates.
Deploy on Replit with .replit and run.sh.
Implement WebRTC with Django Channels, Google STUN servers, and a TURN stub.
Use python-decouple for environment variables.
Achieve 90%+ test coverage with pytest.
Ensure video/audio recordings are stored and downloadable.
Required Libraries
Core Django: django, djangorestframework, django-channels, channels-redis, django-allauth, django-cors-headers, psycopg2-binary (future Postgres), python-decouple, sentry-sdk, pytest, pytest-django.
Payments: razorpay.
Video Signaling: daphne, asgiref.
AI: google-cloud-aiplatform (Gemini API).
Background Tasks: celery, redis.
Multi-Language: django-i18n.
Offline Support: django-offline.
Testing/Linting: black, isort, flake8.
API Keys (Test Mode)
RAZORPAY_KEY_ID: rzp_test_ebT608Q3yd4RCS
RAZORPAY_KEY_SECRET: mGosJfwuEiL1GndUI2kicrL7
GEMINI_API_KEY: AIzaSyCqPqlIcNM68wkqvoSZu6Tl3nMhlh2sh1Q
UI/UX Specifications
Color Scheme: Orange (#FF5734) for CTAs, Purple (#BE94F5) for accents, Yellow (#FCCC42) for highlights, Light Gray (#F7F7F5) for backgrounds, Dark Text (#151515).
Typography: Poppins Bold (24–32px) for headlines, Inter Regular (14–16px) for body.
Glassmorphism: backdrop-filter: blur(12px); background: rgba(255,255,255,0.6) for cards, sidebars.
Animations: Hover lift (transform: translateY(-4px)), button pulse (@keyframes pulse), slide transitions (transform: translateX(100%)), fade (0.5s), Lottie loaders (e.g., "rocket launch", "checkmark").
Responsiveness: Desktop (fixed layouts), tablet (adjustable columns), mobile (bottom nav, swipeable carousels, full-screen forms).
Gamification: Progress bars, badges with unlock animations, confetti (Lottie) on success, leaderboards with real-time updates.
Step-by-Step Instructions
Step 1: Initialize Replit Environment
What to Do: Set up a Python project on Replit named "peerlearn," automate startup with a script for video streaming, install all required libraries, configure environment variables securely, initialize git, and set up multi-language support.
How: Create a Python repl, add libraries to requirements.txt, set Secrets (API keys, DJANGO_SECRET_KEY), create .replit (run = "bash run.sh") and run.sh (install deps, migrate, start server on 0.0.0.0:8000), run git init with .gitignore (.env, db.sqlite3), configure settings.py for django-i18n with English and Spanish.
Cross-Check: Server starts, all libraries installed, environment variables load, video server readiness confirmed, language switch works.
Log: “Step 1 ✅ - Replit environment ready with multi-language support.”
Step 2: Django Project Scaffolding
What to Do: Initialize Django project with apps (users, video, payments, ai, search, notifications, leaderboard), configure settings for Channels, REST framework, allauth, SQLite3, i18n, offline mode, and ASGI, create base.html with Tailwind CSS CDN and language switcher.
How: Run django-admin startproject peerlearn .., create apps, update settings.py (add apps, Channels with Redis, SQLite3, ASGI, i18n, offline mode), design base.html with Tailwind CDN, add language dropdown.
Cross-Check: Server runs, Channels configured, templates render with Tailwind, language switcher functional, offline mode stub works.
Log: “Step 2 ✅ - Django scaffolded with i18n and offline support.”
Step 3: User Models & Authentication
What to Do: Create CustomUser model with roles (learner, mentor, admin), implement multi-step registration, configure allauth for email/social login, add 2FA with email codes, set role-based redirects.
How: Define CustomUser in users/models.py with fields (role, interests, bio, profile_picture, is_approved, 2fa_enabled), set AUTH_USER_MODEL, use allauth, build multi-step forms in users/views.py with Django templates, add 2FA view with Celery for email.
Cross-Check: Registration/login with 2FA work, redirects match roles, only Django templates used.
Log: “Step 3 ✅ - Authentication with 2FA done.”
Step 4: Database Models
What to Do: Define models (Session, Recording, Booking, Notification, Leaderboard, OfflineData) in Django, seed test data with multi-language support.
How: Create models in video/models.py, payments/models.py, notifications/models.py, leaderboard/models.py, run migrations, seed 10 sessions with recordings, 5 notifications, and leaderboard entries in English/Spanish.
Cross-Check: Models work, seed data includes videos and notifications, multi-language fields render correctly.
Log: “Step 4 ✅ - Models set up with multi-language support.”
Step 5: REST API Endpoints
What to Do: Create endpoints for sessions, recordings, bookings, notifications, leaderboard, offline sync, secure with token authentication and rate limiting.
How: Use DRF for serializers and viewsets, add URLs with router, enforce authentication, add django-ratelimit middleware.
Cross-Check: Endpoints return data, authentication enforced, rate limiting active, offline sync stub works.
Log: “Step 5 ✅ - APIs implemented with rate limiting.”
Step 6: WebSocket Signaling for Video
What to Do: Configure Django Channels for WebRTC signaling, build consumer for SDP/ICE, add notification WebSocket, leaderboard updates.
How: Set up video/routing.py and consumers.py, use Redis channel layer, add notifications/consumers.py and leaderboard/consumers.py.
Cross-Check: WebSocket connects instantly, no latency, notifications and leaderboard updates work, only authenticated users connect.
Log: “Step 6 ✅ - Signaling optimized with notifications and leaderboards.”
Step 7: WebRTC Video Setup
What to Do: Implement WebRTC with screen sharing, whiteboard, raise hand, recording, sound notifications, AI transcription, offline mode sync, optimize for no delays.
How: Design session_room.html with video frames, controls, JavaScript for WebRTC (STUN: stun:stun.l.google.com:19302), add MediaRecorder for recording, Gemini API for transcription, offline cache with django-offline, optimize with H.264 and adaptive bitrate.
Cross-Check: Video streams without delay, all features work, recordings and transcripts save, offline mode syncs data.
Log: “Step 7 ✅ - WebRTC optimized with AI transcription and offline support.”
Step 8: UI Framework & Premium Pages
What to Do: Design premium UI with Tailwind CSS, implement dark/light mode, multi-language support, build all pages with advanced functionality.
How: Style templates with Tailwind, add theme toggle, create pages as per detailed UI/UX blueprint below with i18n translations, add offline mode indicators.
Cross-Check: UI is responsive, premium, theme toggle works, language switch functional, offline indicators display, only Django templates used.
Log: “Step 8 ✅ - UI done with multi-language and offline support.”
Step 9: Payment Integration
What to Do: Integrate Razorpay for bookings, verify payments, update bookings, add offline payment confirmation.
How: Create views for order creation and verification, add checkout template, implement offline payment stub with sync.
Cross-Check: Payments process, bookings update, offline confirmation works.
Log: “Step 9 ✅ - Payments integrated with offline support.”
Step 10: AI Recommendations & Search
What to Do: Implement AI-driven recommendations with Gemini, build search with filters, add real-time transcription analysis.
How: Use Gemini API in ai/views.py for recommendations and transcription, create search view and template with filters (language, domain).
Cross-Check: Recommendations match interests, search works, transcript analysis updates dashboard.
Log: “Step 10 ✅ - AI implemented with transcription analysis.”
Step 11: Notifications & Leaderboards
What to Do: Implement real-time notifications (email, in-app), gamified leaderboards with badges, offline sync.
How: Use Celery for email notifications, WebSocket for in-app, design leaderboard/views.py with badge unlocks, sync offline data.
Cross-Check: Notifications trigger, leaderboards update, offline sync works.
Log: “Step 11 ✅ - Notifications and leaderboards implemented.”
Step 12: Testing & Deployment
What to Do: Test all components (video, AI, payments, offline), deploy on Replit with persistent running.
How: Write pytest tests (90%+ coverage), test video performance, configure .replit for continuous operation, verify multi-language and offline mode.
Cross-Check: Tests pass, video performs, server runs continuously, all features work across languages.
Log: “Step 12 ✅ - Deployed with full functionality.”
Detailed UI/UX Blueprint for Each Page (Enhanced)
1. Landing Page (/)
Purpose: Attract visitors, showcase sessions/mentors, drive registration/login.
Layout: Desktop (top nav 80px, hero 600px, main 1200px max-width, footer 200px), Mobile (hamburger menu 40x40px, stacked hero 400px, swipeable carousels).
Content: Top Nav (logo, links, CTAs), Hero (H1, Lottie “rocket launch”, “Get Started”), Featured Sessions (carousel, 4 cards), Top Mentors (3x2 grid), Testimonials (3 cards), Footer (links, social icons).
Advanced Functionality: Real-time session availability, AI search suggestions, language switcher, offline mode teaser.
Transitions: Hero fade, carousel slide, nav toggle slide.
Loader: Lottie “rocket launch”.
Responsive: Tablet (2-column grid), Mobile (full-screen hero).
2. Login Page (/login/)
Purpose: Authenticate with 2FA.
Layout: Desktop (400x600px card), Mobile (full-width card, sticky button).
Content: Header (logo, H1), Illustration (“unlocking door”), Form (email, password, 2FA code, social login), “Sign Up” link.
Advanced Functionality: Password strength, auto-focus, 2FA email, language switch.
Transitions: Card fade, loader spin.
Loader: Lottie “spinning globe”.
Responsive: Tablet (350px card), Mobile (stacked buttons).
3. Learner Registration (4 Steps, /register/learner/)
Purpose: Onboard learners with gamification.
Layout: Desktop (500x700px card), Mobile (full-screen, sticky “Next”).
Content: Progress Bar (25% per step), Step 1 (name, email, password), Step 2 (interests with AI suggestions), Step 3 (goal), Step 4 (profile pic, confetti).
Advanced Functionality: Email validation, AI suggestions, gamified tooltips, offline save.
Transitions: Slide left-to-right, confetti on finish.
Loader: Lottie “loading dots”.
Responsive: Mobile (progress dots).
4. Mentor Registration (4 Steps, /register/mentor/)
Purpose: Onboard mentors with media.
Layout: Same as learner.
Content: Step 1 (same), Step 2 (domain, skills), Step 3 (bio, media), Step 4 (availability, approval page).
Advanced Functionality: Video preview, slot conflict check, offline sync.
Transitions: Same as learner, fade to approval.
Loader: Lottie “waiting”.
Responsive: Same as learner.
5. Learner Dashboard (/dashboard/learner/)
Purpose: Browse, book, manage sessions.
Layout: Desktop (sidebar 250px + main), Mobile (bottom nav 60px, full-width).
Content: Sidebar (links), Header (search, notifications), Main (progress ring, recommendations, mentor grid, post form, cart, leaderboards).
Advanced Functionality: AI recommendations, real-time updates, offline mode, language switch.
Transitions: Fade in, modal scale.
Loader: Lottie “spinning book”.
Responsive: Tablet (2-column), Mobile (swipeable carousels).
6. Mentor Dashboard (/dashboard/mentor/)
Purpose: Manage sessions, analytics.
Layout: Same as learner.
Content: Sidebar (links), Main (stats, top learners, badges, sessions, chart, feedback).
Advanced Functionality: Real-time requests, interactive chart, offline sync.
Transitions: Same as learner.
Loader: Lottie “spinning book”.
Responsive: Same as learner.
7. Session Detail & Booking Modal
Purpose: Display details, handle booking.
Layout: Modal (600x800px).
Content: Header (title), Content (thumbnail, details, picker), Buttons (“Confirm” or “Cart”).
Advanced Functionality: Slot check, payment preview, offline booking stub.
Transitions: Scale up, fade out.
Loader: Lottie “loading book”.
Responsive: Mobile (full-screen).
8. Cart & Checkout (/cart/)
Purpose: Review and pay.
Layout: Centered card (800x600px).
Content: Session List (cards), Total, Checkout Button.
Advanced Functionality: Real-time updates, offline confirmation.
Transitions: Cards slide, modal fade.
Loader: Lottie “payment processing”.
Responsive: Mobile (vertical stack).
9. Live Session Room (/session/<room_id>/)
Purpose: Host video with advanced features.
Layout: Desktop (video 70% + sidebar 30%), Mobile (full-width video, bottom sheet).
Content: Top Bar (title, timer, controls), Video Area (videos, controls), Sidebar (topic analyzer, agenda, chat, transcript, offline toggle).
Advanced Functionality: WebRTC, AI transcription, offline sync, raise hand, whiteboard.
Transitions: Videos fade, sidebar slide.
Loader: Lottie “video loading”.
Responsive: Mobile (swipe-up sidebar).
10. Feedback Modal
Purpose: Collect feedback.
Layout: Modal (400x300px).
Content: Header (“Rate”), Content (stars, comment), “Submit” button.
Advanced Functionality: Rating preview, confetti, offline save.
Transitions: Scale up, fade out.
Loader: Lottie “checkmark”.
Responsive: Mobile (full-screen).
11. Profile & Settings (/profile/)
Purpose: Edit details.
Layout: Centered card (600x800px).
Content: Avatar (editable), Form (fields, toggles), “Save” button.
Advanced Functionality: Validation, theme persistence, language switch.
Transitions: Fade in, ripple on save.
Loader: Lottie “saving”.
Responsive: Mobile (full-width).
12. Admin Panel (/admin/)
Purpose: Manage users, sessions.
Layout: Tailwind-styled Django admin.
Content: Tables (users, sessions), Actions (approve, delete).
Advanced Functionality: Real-time updates, bulk actions, offline sync.
Transitions: Rows fade in.
Loader: Lottie “loading table”.
Responsive: Mobile (horizontal scroll).
13. Error Pages (401/403/404/500)
Purpose: Handle errors.
Layout: Centered card (400x400px).
Content: Illustration (“error”), Message, “Back to Home” button.
Advanced Functionality: Retry option, support link, offline fallback.
Transitions: Card fade in.
Responsive: Mobile (full-width).
Advanced Functionality Clarifications
1. Live Sessions with Real-Time Video
How It Works: Access control via models, WebRTC with STUN, Django Channels, features synced via WebSocket.
Features: Screen sharing, whiteboard, raise hand, recording, AI transcription (Gemini), offline sync, sound notifications.
Optimization: H.264, adaptive bitrate, 3 reconnection attempts.
2. Mentor & Learner Dashboards
Mentor Dashboard: Real-time stats, charts, session management, offline data.
Learner Dashboard: AI recommendations, bookings, posts, leaderboards, offline mode.
Backend: Views with WebSocket updates.
3. ML-Based Recommendations
Logic: Content-based, collaborative filtering via Gemini.
Implementation: /api/recommendations/, WebSocket updates.
4. Payment Integration
Flow: Order creation, Razorpay checkout, verification, offline confirmation.
Backend: payments/views.py.
5. AI Transcription
Logic: Real-time audio-to-text with Gemini, saved to session.
Implementation: WebSocket stream to API, /api/transcript/.
6. Leaderboards
Logic: Rank users by sessions completed, badges unlocked.
Implementation: leaderboard/views.py, WebSocket updates.
7. Offline Mode
Logic: Cache data locally, sync on reconnect.
Implementation: django-offline, WebSocket sync.
8. Multi-Language Support
Logic: Translate UI and data with i18n.
Implementation: settings.py, templates with {% trans %}.
User Flows (End-to-End)
Visitor Flow
Landing Page: View nav, scroll, click “Register” → Role Selection → Registration.
Learner Flow
Registration: 4 steps → Dashboard → Browse, book, join sessions, provide feedback, view leaderboards.
Live Session: Join 10 min before, use controls, end with feedback.
Mentor Flow
Registration: 4 steps → Approval → Dashboard → Create sessions, join, view analytics.
Live Session: Same as learner, with mute-all.
Cross-Check After Each Step
Automated Tests: Pytest (90%+ coverage).
Manual QA: Test on desktop, tablet, mobile (no breaks).
Video Performance: No delays, all features work.
Security: No vulnerabilities.
Responsiveness: Adapts to all devices.
Multi-Language: English/Spanish functional.
Offline Mode: Data syncs correctly.

Master Prompt for Building PeerLearn (Strict Compliance Version)
Project Name: PeerLearn
prompt below, which includes stricter language and detailed UI/UX specifications.
Clarify in Chat: After pasting, add: “Follow the prompt exactly. Use only Django, SQLite3, Django Channels, WebRTC, Tailwind CSS CDN. No React, Vue, or other frameworks. Implement all advanced features (screen sharing, whiteboard, raise hand, recording, sound notifications) in order, with premium, gamified UI/UX including glassmorphism, animations, and responsive design.”
Monitor Outputs: After each step, check requirements.txt, templates, and JavaScript files to ensure no React or unauthorized libraries are added.
Break Down Instructions: If the agent struggles, split the prompt into smaller chunks (e.g., one step at a time) and verify compliance before proceeding.
Report Deviations: If issues persist, share the agent’s output (e.g., generated code or error logs), and I’ll refine the prompt further.
Detailed UI/UX Blueprint for Each Page
Below is a step-by-step breakdown of each page in PeerLearn, including purpose, layout, content, container sizes, borders, glassmorphism, animations, transitions, loaders, color scheme, and responsive behavior. All designs use Tailwind CSS via CDN, ensuring a premium, gamified, video-centric UI/UX with no React or other frameworks. Each page includes hover/click effects, smooth transitions, and mobile-first responsiveness.

Color Scheme (Applied Across All Pages)
Primary: Orange (#FF5734) – CTAs, highlights
Accent: Purple (#BE94F5) – Secondary buttons, badges
Highlight: Yellow (#FCCC42) – Progress bars, notifications
Neutral Light: Gray (#F7F7F5) – Backgrounds
Dark Text: (#151515) – Text, borders
Glassmorphism: backdrop-filter: blur(12px); background: rgba(255,255,255,0.6); – Cards, sidebars
Typography
Headlines: Poppins Bold, 24–32px
Body: Inter Regular, 14–16px
Buttons: Poppins Medium, 16px
Animations (Using Tailwind + Custom CSS)
Hover Lift: transform: translateY(-4px); transition: all 0.3s ease;
Button Pulse: @keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.05); } }
Slide Transition: transform: translateX(100%); transition: transform 0.5s ease-in-out;
Confetti: Lottie animation triggered on success (e.g., registration completion)
Loader: Lottie “rocket launch” animation, centered, 200x200px
1. Landing Page (/)
Purpose: Attract visitors, showcase sessions/mentors, and drive registration/login.
Layout:

Desktop:
Top Nav: Fixed, 100% width, 80px height, bg-white/80 backdrop-blur-md (glassmorphism).
Hero: Full-width, 600px height, bg-gradient-to-r from-orange-500 to-purple-500.
Main Content: 1200px max-width, centered, grid layout.
Footer: 100% width, 200px height, bg-gray-900 text-white.
Mobile:
Hamburger menu (top-right, 40x40px) toggles sidebar.
Hero stacks vertically, 400px height.
Content in single-column, swipeable carousels.
Content & Containers:

Top Nav (80px height, border-b border-gray-200):
Logo (left, 150x50px, SVG).
Links: “Live Sessions,” “Mentors,” “About,” “Support” (16px, text-gray-800 hover:text-orange-500).
CTAs: “Login” (outline button, border-orange-500), “Register” (solid button, bg-orange-500 text-white).
Hover: Links underline, buttons pulse.
Hero:
Left: H1 (“Learn 1:1 with Top Mentors”), 32px, Poppins Bold.
Right: Lottie animation (“rocket launch,” 300x300px).
CTA: “Get Started” (button, 200x50px, bg-orange-500 hover:bg-orange-600, pulse animation).
Animation: Text fades in, rocket slides up on load.
Featured Sessions:
Horizontal carousel, 4 cards (300x400px each, bg-white/60 backdrop-blur-md shadow-lg rounded-xl).
Card: Thumbnail (300x200px), Title (16px), Mentor (14px), “Book” button (150x40px, bg-orange-500).
Hover: Card lifts, button glows.
Mobile: Swipeable, 1 card visible.
Top Mentors:
Grid (3x2, 350x250px cards, border border-gray-200 rounded-lg).
Card: Avatar (100x100px), Name, Expertise, “Follow” button.
Hover: Avatar scales, button pulses.
Testimonials:
3 cards (400x200px, bg-purple-100 rounded-lg).
Text (14px), Star Rating (5 yellow stars), User Name.
Animation: Cards slide in on scroll.
Footer:
Links: “Privacy,” “Terms,” “Contact” (14px).
Social Icons (40x40px, hover:text-orange-500).
Transitions:

Page load: Hero fades in (0.5s), carousel slides from right.
Button click: Ripple effect, transition: background-color 0.3s.
Nav toggle (mobile): Sidebar slides in from left.
Loader:

Lottie “rocket launch” (200x200px), centered, shown during API calls.
Responsive Behavior:

Tablet: 2-column mentor grid, hero text smaller (24px).
Mobile: Single-column, hamburger menu, hero button full-width.
Backend:

View: views.landing renders landing.html.
Data: Session.objects.filter(is_featured=True) for carousel, CustomUser.objects.filter(role='mentor', is_featured=True) for mentors.
2. Login Page (/login/)
Purpose: Authenticate users via email/password or social login.
Layout:

Desktop: Centered card (400x600px, bg-white/80 backdrop-blur-md rounded-xl shadow-lg).
Mobile: Full-width card, 16px padding, sticky “Login” button.
Content & Containers:

Header: Logo (150x50px), “Welcome Back!” (H1, 24px, Poppins Bold).
Illustration: unDraw “unlocking door” (200x200px, centered).
Form (300x300px, border border-gray-200 rounded-lg):
Email Input (100% width, 48px height, border-gray-300 focus:border-orange-500).
Password Input (with eye-toggle, same size).
Hover: Input border glows orange.
Error: Inline “Invalid credentials” (red, 12px).
Login Button: 200x50px, bg-orange-500 hover:bg-orange-600, pulse animation.
Social Login: “Login with Google/Facebook” (2 buttons, 150x40px, border-gray-300 hover:bg-gray-100).
Link: “Don’t have an account? Sign Up” (14px, text-orange-500 hover:underline).
Transitions:

Page load: Card fades in, illustration slides up.
Form submit: Button ripples, loader appears if delayed.
Loader:

Lottie “spinning globe” (150x150px), shown during authentication.
Responsive Behavior:

Tablet: Card 350px wide.
Mobile: Form full-width, buttons stack vertically.
Backend:

View: users.views.login_view handles POST /api/login/.
Allauth: Configured for email and social (Google/Facebook) login.
On success: Redirect to /dashboard/<role>/.
3. Learner Registration (4 Steps, /register/learner/)
Purpose: Onboard learners with a gamified, multi-step form.
Layout:

Desktop: Centered card (500x700px, bg-white/80 backdrop-blur-md rounded-xl).
Mobile: Full-screen, sticky “Next” button at bottom.
Content & Containers (Per Step):

Progress Bar: Top, 100% width, 10px height, bg-gray-200 with bg-orange-500 fill (25% per step).
Step 1: Basic Info:
Illustration: “Waving hand” (200x200px).
Fields (300x48px each, border-gray-300 focus:border-orange-500):
Full Name, Email, Password, Confirm Password.
Validation: Real-time email check (/api/check_email/), password strength bar.
Gamification: “Complete Step 1 to unlock badge!” (tooltip, 12px).
Button: “Next” (200x50px, bg-orange-500).
Step 2: Interests:
Illustration: “Map & Pin” (200x200px).
Tag Input (300x100px, border-gray-300).
Suggestions (via Gemini API, 5 chips, bg-purple-100 hover:bg-purple-200).
Error: “Select at least 1 tag” (red, 12px).
Button: “Next.”
Step 3: Career Goal:
Illustration: “Rocket launch” (200x200px).
Dropdown (300x48px, pre-populated: “ML Engineer,” etc.) + Free-text.
Tooltip: “Set a goal for better recommendations!” (12px).
Button: “Next.”
Step 4: Profile Picture:
Illustration: “Avatar placeholder” (200x200px).
Upload Button (200x50px, border-dashed border-gray-300).
Validation: JPEG/PNG, ≤2MB.
Button: “Finish” (on success: confetti animation).
Hover: Upload button glows, card lifts.
Transitions:

Step change: Slide left-to-right (0.5s), fields fade in.
Submit: Confetti (2s), redirect to /dashboard/learner/.
Loader:

Lottie “loading dots” (100x100px) during API calls.
Responsive Behavior:

Mobile: Full-screen steps, progress dots instead of bar, sticky “Next” button.
Backend:

View: users.views.register_learner uses session storage for partial data.
Model: CustomUser (role='learner', interests, career_goal).
On submit: POST /api/register/learner/, auto-login.
4. Mentor Registration (4 Steps, /register/mentor/)
Purpose: Onboard mentors with expertise and media.
Layout: Same as learner registration (500x700px card, mobile full-screen).

Content & Containers:

Progress Bar: Same as learner.
Step 1: Basic Info: Same as learner.
Step 2: Expertise & Skills:
Illustration: “Toolbox” (200x200px).
Two Tag Inputs (300x100px): Domain (e.g., “Python”), Skills.
Error: “Select at least 1 domain” (red, 12px).
Button: “Next.”
Step 3: Bio & Media:
Illustration: “Camera” (200x200px).
Bio Textarea (300x150px, 150–500 chars).
Profile Image Upload (200x50px, border-dashed).
Intro Video URL/Upload (300x48px).
Validation: Video ≤5MB, valid URL.
Button: “Next.”
Step 4: Availability:
Illustration: “Calendar” (200x200px).
Optional Day/Time Slots (checkbox grid, 300x200px).
Button: “Finish” (shows “Pending Approval” page).
Transitions:

Same slide and fade as learner registration.
Approval page: Fades in with Lottie “waiting” animation.
Loader: Same as learner.

Responsive Behavior: Same as learner.

Backend:

View: users.views.register_mentor.
Model: CustomUser (role='mentor', is_approved=False).
Admin approval updates is_approved=True, emails user.
5. Learner Dashboard (/dashboard/learner/)
Purpose: Central hub for learners to browse, book, and manage sessions.
Layout:

Desktop: Sidebar (250px width, fixed) + Main Content (flex-1).
Mobile: Bottom nav (60px height), content full-width.
Content & Containers:

Sidebar (250x100% height, bg-white/80 backdrop-blur-md):
Links: “Live Sessions,” “Mentors,” “My Posts,” “My Bookings,” “Cart,” “Profile,” “Settings” (16px, hover:bg-orange-100).
Mobile: Bottom nav with icons (40x40px).
Header (100% width, 80px height, bg-white shadow):
Search Bar (300x40px, border-gray-300 focus:border-orange-500).
Notifications Bell (40x40px, hover:text-orange-500).
Profile Dropdown (150x40px, bg-gray-100 rounded-lg).
Hover: Bell pulses, dropdown expands.
Main Content (1200px max-width, grid):
Progress & Achievements (600x200px, bg-white/60 backdrop-blur-md rounded-xl):
Progress Ring (100x100px, SVG, animates on load).
Badges (4x 80x80px, border-gray-200 rounded-full, hover reveals criteria).
Animation: Ring fills, badges slide in.
Recommended Sessions (600x400px, carousel):
Cards (300x400px, bg-white/80 backdrop-blur-md shadow-lg).
Filters: Free/Paid, Time, Price (dropdowns, 150x40px).
Hover: Card lifts, “Book” button pulses.
Browse Mentors (600x300px, grid):
Mentor Cards (200x250px, border-gray-200).
“Follow” Button (100x40px, bg-purple-500).
My Posts (600x300px, bg-white rounded-lg):
Form: Topic, Duration, Time (300x48px inputs).
Post List: Status (Open/Accepted, 300x100px cards).
WebSocket: Updates status in real-time.
Cart & Bookings (600x400px):
Cart: Session list, “Checkout” button (200x50px, bg-orange-500).
Bookings: Upcoming/Past (300x150px cards, “Join”/Download).
Hover: Buttons glow.
Transitions:

Page load: Sections fade in sequentially (0.3s delay each).
Navigation: Content slides in from right.
Booking: Modal fades in, scales up.
Loader: Lottie “spinning book” (150x150px) during API calls.

Responsive Behavior:

Tablet: 2-column grid, sidebar collapsible.
Mobile: Single-column, bottom nav, swipeable carousels.
Backend:

View: users.views.learner_dashboard.
Data: Session.objects.filter(is_active=True) for recommendations (Gemini API), Booking.objects.filter(user=request.user) for bookings.
WebSocket: ws://.../ws/notifications/ for real-time updates.
6. Mentor Dashboard (/dashboard/mentor/)
Purpose: Manage sessions, respond to requests, and track analytics.
Layout: Same as learner (sidebar + main content).

Content & Containers:

Sidebar: Links: “Dashboard,” “Create Session,” “Requests,” “My Sessions,” “Analytics,” “Earnings,” “Profile.”
Header: Same as learner.
Main Content:
Quick Stats (600x150px, bg-white/60 backdrop-blur-md):
4 Cards (150x100px): Upcoming, Pending, Earnings, Badges.
Hover: Cards lift, stats animate up.
Top Learners (600x200px, carousel):
Avatar Cards (100x100px, border-gray-200 rounded-full).
Click: Opens profile popup (300x400px, bg-white shadow-lg).
Streak & Badges (600x150px):
Streak: “10-day teaching streak” (16px, bg-orange-100 rounded-lg).
Badges: 4x 80x80px, hover reveals criteria.
Upcoming Sessions (600x400px, carousel):
Cards (300x200px, bg-white/80 backdrop-blur-md).
“Join” Button (150x40px, bg-orange-500, pulses in join window).
Performance Chart (600x300px, bg-white rounded-lg):
Chart.js line chart (sessions/month, 500x200px).
Hover: Tooltips show data.
Quick Actions (600x100px):
Buttons: “Create Session,” “Respond to Requests” (150x40px, bg-purple-500).
Recent Feedback (600x200px):
Cards (300x100px, bg-purple-100): Stars, Comment, Learner.
Transitions: Same as learner dashboard.

Loader: Same as learner.

Responsive Behavior: Same as learner.

Backend:

View: users.views.mentor_dashboard.
Data: Session.objects.filter(mentor=request.user), Booking.objects.filter(session__mentor=request.user).
WebSocket: Real-time updates for requests and bookings.
7. Session Detail & Booking Modal
Purpose: Display session details and handle booking.
Layout: Modal (600x800px, bg-white/80 backdrop-blur-md rounded-xl, centered).

Content & Containers:

Header: Session Title (24px), Close Button (40x40px, hover:bg-gray-100).
Content (560x700px):
Thumbnail (560x300px).
Description (16px, 500x200px).
Tags (chips, bg-purple-100).
Free/Paid Badge (100x40px, bg-green-500 or bg-orange-500).
Date/Time Picker (300x48px).
Hover: Picker glows, badge pulses.
Buttons:
Free: “Confirm Booking” (200x50px, bg-orange-500).
Paid: “Add to Cart” (200x50px, bg-purple-500).
Animation: Ripple on click.
Transitions:

Modal: Scales up and fades in (0.3s).
Close: Fades out, scales down.
Loader: Lottie “loading book” during booking API call.

Responsive Behavior:

Mobile: Full-screen modal, sticky buttons.
Backend:

View: video.views.session_detail.
API: POST /api/book/ for free, POST /api/cart/add/ for paid.
8. Cart & Checkout (/cart/)
Purpose: Review and pay for sessions.
Layout: Centered card (800x600px, bg-white rounded-xl).

Content & Containers:

Session List (760x400px, border-gray-200):
Cards (760x100px): Title, Mentor, Price, “Remove” button.
Hover: Card lifts, button turns red.
Total (760x100px): Price (24px, text-orange-500).
Checkout Button: 200x50px, bg-orange-500, triggers Razorpay.
Transitions:

Page load: Cards slide in.
Checkout: Razorpay modal fades in.
Loader: Lottie “payment processing” (150x150px).

Responsive Behavior:

Mobile: Full-width, vertical stack.
Backend:

View: payments.views.cart.
API: POST /api/create_order/ (Razorpay), POST /api/verify_payment/.
9. Live Session Room (/session/<room_id>/)
Purpose: Host real-time video with advanced features.
Layout:

Desktop: Video Area (70%) + Sidebar (30%, bg-white/60 backdrop-blur-md).
Mobile: Full-width video, sidebar as bottom sheet.
Content & Containers:

Top Bar (100% width, 60px, bg-white shadow):
Session Title (16px), Timer (16px, text-orange-500).
Buttons: Record, Mute All, Settings (40x40px, hover:bg-gray-100).
Video Area (800x600px):
Mentor/Learner Videos (400x300px each, border-gray-200).
Controls: Mute, Camera, Share Screen, Whiteboard, Raise Hand (40x40px icons, hover:bg-orange-500).
Hover: Controls glow, videos scale slightly.
Sidebar (400x600px):
Topic Analyzer: Progress bars (300x100px, Gemini API).
Agenda: List (300x200px, border-gray-200).
Action Items: Buttons (Next/Skip, 150x40px).
Chat: Textarea + Messages (300x200px).
Transcript Pane (bottom, 100% width, 200px, collapsible):
Text (14px), Download Button (150x40px).
Animation: Auto-scrolls, toggle fades.
Transitions:

Page load: Videos fade in, sidebar slides from right.
Leave: Feedback modal scales up.
Loader: Lottie “video loading” (200x200px) during WebRTC setup.

Responsive Behavior:

Mobile: Video full-width, controls dock bottom, sidebar swipe-up sheet.
Backend:

View: video.views.session_room.
WebSocket: ws://.../ws/video/<room_id>/ for signaling.
WebRTC: simple-peer in JavaScript, STUN servers.
Recording: MediaRecorder saves to /media/recordings/.
10. Feedback Modal
Purpose: Collect session feedback.
Layout: Modal (400x300px, bg-white/80 backdrop-blur-md).

Content & Containers:

Header: “Rate This Session” (24px).
Stars: 5 icons (40x40px, hover:text-yellow-500).
Comment: Textarea (360x100px).
Submit Button: 200x50px, bg-orange-500.
Transitions: Scales up on open, fades out on submit.

Loader: Lottie “checkmark” on success.

Responsive Behavior: Full-screen on mobile.

Backend:

API: POST /api/feedback/.
11. Profile & Settings (/profile/)
Purpose: Edit user details and preferences.
Layout: Centered card (600x800px, bg-white rounded-xl).

Content & Containers:

Avatar: 100x100px, border-gray-200 rounded-full.
Form: Fields for Name, Interests, Bio, etc. (300x48px).
Toggles: Dark/Light Mode, Notifications (150x40px).
Save Button: 200x50px, bg-orange-500.
Transitions: Fields fade in, save ripples.

Loader: Lottie “saving” during submit.

Responsive Behavior: Full-width on mobile.

Backend:

View: users.views.profile.
12. Admin Panel (/admin/)
Purpose: Manage users, sessions, and approvals.
Layout: Django admin default, styled with Tailwind.

Content & Containers:

Tables: Users, Sessions, Payments (100% width, border-gray-200).
Actions: Approve Mentor, Delete Session (150x40px buttons).
Transitions: Rows fade in.

Loader: Lottie “loading table”.

Responsive Behavior: Tables scroll horizontally on mobile.

Backend:

Default Django admin, extended with custom actions.
13. Error Pages (401/403/404/500)
Purpose: Handle errors gracefully.
Layout: Centered card (400x400px, bg-white/80 backdrop-blur-md).

Content & Containers:

Illustration: unDraw “error” (200x200px).
Message: “Page Not Found” (24px).
Button: “Back to Home” (200x50px, bg-orange-500).
Transitions: Card fades in.

Loader: None.

Responsive Behavior: Full-width on mobile.

Backend:

Views: views.error_404, etc.
Advanced Functionality Clarifications
1. Live Sessions with Real-Time Video
How It Works:
Access Control: Session model checks booking status (payments.models.Booking).
WebRTC: JavaScript in session_room.html uses RTCPeerConnection with STUN (stun:stun.l.google.com:19302).
Signaling: Django Channels (video.consumers.VideoConsumer) exchanges SDP/ICE via WebSocket.
Features:
Screen Sharing: getDisplayMedia, synced via WebSocket.
Whiteboard: <canvas> element, strokes sent via WebSocket.
Raise Hand: Button sends WebSocket message, displays badge.
Recording: MediaRecorder saves MP4 to /media/recordings/.
Notifications: Audio files (join.mp3) played on WebSocket events.
Optimization: H.264 codec, adaptive bitrate, 3 reconnection attempts.
Backend:
video/routing.py: ws/video/<room_id>/.
video/consumers.py: Handles SDP, ICE, and feature messages.
video/views.py: Renders session_room.html, checks access.
2. Mentor & Learner Dashboards
Mentor Dashboard:
Stats: Queried from Session and Payment models.
Charts: Chart.js in mentor_dashboard.html.
Real-Time: WebSocket (ws://.../ws/notifications/) updates requests, earnings.
Learner Dashboard:
Recommendations: Gemini API (ai/views.py) matches interests to sessions.
Bookings: Booking model, real-time updates via WebSocket.
Backend:
users/views.py: Dashboard views.
ai/views.py: Recommendation logic.
3. ML-Based Recommendations
Logic:
Content-based: Matches user.interests to Session.tags.
Collaborative: Uses similar users’ bookings (Groq API).
Implementation:
ai/views.py: Calls google-cloud-aiplatform for predictions.
API: /api/recommendations/ returns session IDs.
Display: Cards in learner_dashboard.html, updated via WebSocket.
4. Payment Integration
Flow:
POST /api/create_order/: Creates Razorpay order.
Razorpay.js: Handles payment UI.
POST /api/verify_payment/: Verifies signature, updates Booking.
Backend:
payments/views.py: Order and verification logic.
Celery: Sends confirmation emails.
Revised Master Prompt
Below is an updated Master Prompt with stricter instructions, enhanced UI/UX details, and explicit prohibitions to prevent deviations. It incorporates all your requirements and addresses the agent’s issues.

Master Prompt for Building PeerLearn (Strict Compliance Version)

Project Name: PeerLearn

Objective: You are "PeerLearn Builder," an expert full-stack AI agent tasked with creating PeerLearn, a production-ready, scalable, secure, one-to-one live video learning platform. The platform must deliver real-time, high-quality video sessions with no delays or buffering, featuring Zoom-like advanced capabilities (screen sharing, whiteboard, raise hand, recording, sound notifications) and efficient video storage/server management. You MUST build this using only Django (Python) for backend and frontend (via Django templates), SQLite3 as the only database, and Django Channels for WebRTC-based real-time video. The UI/UX must be premium, responsive, mobile-first, and gamified, styled exclusively with Tailwind CSS via CDN—NO React, Vue, or other frameworks are allowed. Deploy on Replit, installing only required libraries, configuring real-time video, and ensuring security, scalability, and responsiveness across web and mobile. Follow these steps in order, completing each fully with automated tests, manual QA, and responsive/device checks before proceeding. DO NOT DEVIATE from these instructions—every requirement is mandatory, and deviations (e.g., using React, skipping features, or using other databases) are unacceptable.

Critical Instructions
Technology Stack: Use ONLY Django (Python) for backend and frontend (Django templates with Tailwind CSS via CDN). NO React, Vue, or other frontend frameworks. All functionality must be built within Django’s ecosystem.
Database: Use ONLY SQLite3. NO MySQL, MongoDB, or other databases. Configure with environment variables for future PostgreSQL compatibility.
Real-Time Video: Implement WebRTC using Django Channels for signaling. Use Google STUN servers (stun:stun.l.google.com:19302) and include a stub for a future TURN server. Optimize for no delays or buffering.
UI/UX: Deliver a premium, responsive, mobile-first UI/UX with gamification (badges, progress bars, confetti). Use Tailwind CSS via CDN exclusively—NO other CSS frameworks. Implement glassmorphism (backdrop-filter: blur(12px)), hover/click animations, smooth transitions, and Lottie loaders.
Features: Implement ALL advanced features: screen sharing, whiteboard, raise hand, recording, sound notifications (join/leave tones). DO NOT omit any feature.
Compliance: Follow every step in order without skipping. Cross-check after each step to confirm adherence to this prompt. Log progress (e.g., “Step 1 ✅”) and QA report.
Why This Matters
PeerLearn is a complex platform requiring precise execution. Deviations (e.g., using React, skipping features, or using a different database) will fail to deliver a Django-based, real-time video learning solution. Replit’s environment has specific constraints, and strict adherence is critical for success.

Core Requirements
Real-Time Video: High-quality, low-latency streaming with WebRTC, optimized for no delays or buffering.
Advanced Features: Screen sharing, whiteboard, raise hand, recording, Zoom-like sound notifications.
Storage & Server: Efficient video recording storage, scalable server handling for concurrent sessions.
Performance: No delays or buffer issues, even under low-bandwidth conditions.
UI/UX: Intuitive, responsive, video-centric design with gamification (badges, confetti, progress animations).
Security: HTTPS, CSRF protection, CORS lockdown, rate limiting.
Scalability: Docker-ready, modular apps, future-proof for PostgreSQL and TURN servers.
Constraints
Use ONLY Django for backend and frontend (templates with Tailwind CSS CDN).
Use ONLY SQLite3 as the database.
Deploy on Replit with .replit and run.sh for automation.
Implement real-time video using WebRTC with Django Channels, Google STUN servers, and a TURN stub.
Use python-decouple for environment variables.
Achieve 90%+ test coverage with pytest.
Ensure video recordings are efficiently stored and downloadable.
Required Libraries
Core Django: django, djangorestframework, django-channels, channels-redis, django-allauth, django-cors-headers, psycopg2-binary (for future Postgres), python-decouple, sentry-sdk, pytest, pytest-django.
Payments: razorpay.
Video Signaling: daphne, asgiref.
AI: google-cloud-aiplatform (Gemini API), groq.
Background Tasks: celery, redis.
Testing/Linting: black, isort, flake8.
NO OTHER LIBRARIES (e.g., React, Vue) are allowed.
API Keys (Test Mode)
RAZORPAY_KEY_ID: rzp_test_ebT608Q3yd4RCS
RAZORPAY_KEY_SECRET: mGosJfwuEiL1GndUI2kicrL7
GEMINI_API_KEY: AIzaSyCqPqlIcNM68wkqvoSZu6Tl3nMhlh2sh1Q
GROQ_API_KEY: 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
UI/UX Specifications
Color Scheme: Orange (#FF5734), Purple (#BE94F5), Yellow (#FCCC42), Light Gray (#F7F7F5), Dark Text (#151515).
Typography: Poppins Bold (headlines, 24–32px), Inter Regular (body, 14–16px).
Glassmorphism: backdrop-filter: blur(12px); background: rgba(255,255,255,0.6); for cards, sidebars.
Animations:
Hover: transform: translateY(-4px); transition: all 0.3s ease;
Button Pulse: @keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.05); } }
Transitions: Slide (transform: translateX(100%)), fade (0.5s).
Loaders: Lottie animations (“rocket launch,” “spinning book,” 150–200px).
Responsive Design:
Desktop: Fixed sidebars, multi-column grids.
Tablet: Collapsible sidebars, 2-column layouts.
Mobile: Bottom nav, swipeable carousels, sticky buttons.
Gamification: Badges (unlock animations), progress bars (fill on load), confetti (Lottie on success).
Step-by-Step Instructions
Step 1: Initialize Replit Environment
What to Do:
Create a Python project on Replit named “peerlearn.”
Automate startup with a script for video streaming.
Install only required libraries listed above.
Configure environment variables securely.
Initialize git.
How:
Create Python repl.
Add to requirements.txt: django, djangorestframework, django-channels, etc.
Run pip install -r requirements.txt.
Set Secrets: DJANGO_SECRET_KEY, API keys.
Create .replit: run = "bash run.sh".
run.sh: Install deps, migrate, start server (0.0.0.0:8000).
Run git init, add .gitignore (.env, db.sqlite3).
Cross-Check:
Server starts without errors.
pip list shows only required libraries—NO React.
Environment variables load.
Log: “Step 1 ✅ - Replit environment ready.”
Step 2: Django Project Scaffolding
What to Do:
Initialize Django project with apps: users, video, payments, ai, search.
Configure settings for Channels, REST framework, allauth, SQLite3.
Set up ASGI for WebSocket.
Create base.html with Tailwind CSS CDN.
How:
Run django-admin startproject peerlearn ..
Create apps: python manage.py startapp <app_name>.
Update settings.py:
INSTALLED_APPS: Add apps, channels, rest_framework, allauth.
CHANNEL_LAYERS: Redis backend.
DATABASES: SQLite3 ('ENGINE': 'django.db.backends.sqlite3').
ASGI_APPLICATION: peerlearn.asgi.application.
base.html:
html

Copy
<!DOCTYPE html>
<html>
<head>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .glass { backdrop-filter: blur(12px); background: rgba(255,255,255,0.6); }
        @keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.05); } }
    </style>
</head>
<body class="bg-gray-100 font-inter">
    {% block content %}{% endblock %}
</body>
</html>
Cross-Check:
Server runs, admin works.
Channels configured.
Template renders with Tailwind.
NO React in codebase.
Log: “Step 2 ✅ - Django scaffolded.”
Step 3: User Models & Authentication
What to Do:
Create CustomUser model with roles.
Implement multi-step registration with Django templates.
Configure allauth for email/social login.
Set role-based redirects.
How:
users/models.py:
python

Copy
class CustomUser(AbstractUser):
    ROLE_CHOICES = [('learner', 'Learner'), ('mentor', 'Mentor'), ('admin', 'Admin')]
    role = models.CharField(max_length=10, choices=ROLE_CHOICES)
    interests = models.JSONField(default=list)
    bio = models.TextField(blank=True)
    profile_picture = models.ImageField(upload_to='profiles/', blank=True)
    is_approved = models.BooleanField(default=False)
settings.py: AUTH_USER_MODEL = 'users.CustomUser'.
Allauth: Email + Google/Facebook login.
Views: users/views.py for multi-step forms.
Templates: register_learner.html, register_mentor.html with glassmorphism and animations.
Cross-Check:
Registration/login works.
Redirects match roles.
ONLY Django templates—NO React.
Log: “Step 3 ✅ - Authentication done.”
Step 4: Database Models
What to Do:
Define models for sessions, recordings, bookings.
Seed test data.
How:
video/models.py: Session, Recording.
payments/models.py: Booking.
Run makemigrations, migrate.
Seed script: 10 sessions with recordings.
Cross-Check:
Models work, seed data includes videos.
ONLY SQLite3.
Log: “Step 4 ✅ - Models set up.”
Step 5: REST API Endpoints
What to Do:
Create endpoints for sessions, recordings, bookings.
Secure with token authentication.
How:
video/serializers.py, viewsets.py for CRUD.
urls.py: DRF router.
rest_framework.authentication.TokenAuthentication.
Cross-Check:
Endpoints return data (test with Postman).
Authentication enforced.
Log: “Step 5 ✅ - APIs implemented.”
Step 6: WebSocket Signaling for Video
What to Do:
Configure Channels for WebRTC signaling.
Build consumer for SDP/ICE.
How:
video/routing.py: ws/video/<room_id>/.
video/consumers.py: Handle SDP, ICE, feature messages.
Redis channel layer.
Cross-Check:
WebSocket connects instantly.
No latency.
Log: “Step 6 ✅ - Signaling optimized.”
Step 7: WebRTC Video Setup
What to Do:
Implement WebRTC with all Zoom-like features.
Optimize for no delays.
Use STUN, stub TURN.
How:
video/templates/session_room.html:
html

Copy
<div class="flex h-screen">
    <div class="w-7/10">
        <video id="localVideo" autoplay class="w-full h-1/2 border"></video>
        <video id="remoteVideo" autoplay class="w-full h-1/2 border"></video>
        <div class="flex gap-2">
            <button onclick="toggleMic()" class="bg-orange-500 p-2 rounded hover:bg-orange-600">Mic</button>
            <button onclick="startScreenShare()" class="bg-purple-500 p-2 rounded hover:bg-purple-600">Share Screen</button>
            <button onclick="toggleWhiteboard()" class="bg-yellow-500 p-2 rounded hover:bg-yellow-600">Whiteboard</button>
        </div>
    </div>
    <div class="w-3/10 glass p-4">
        <div id="agenda" class="mb-4"></div>
        <div id="transcript" class="h-1/2 overflow-auto"></div>
    </div>
</div>
<script>
    const peerConnection = new RTCPeerConnection({ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] });
    // WebRTC logic
</script>
Optimize: H.264, adaptive bitrate.
Cross-Check:
Video streams without delay.
All features work.
Recordings save.
Log: “Step 7 ✅ - WebRTC optimized.”
Step 8: UI Framework & Theming
What to Do:
Design premium UI with Tailwind CSS.
Implement dark/light mode.
Build all pages.
How:
Style templates with Tailwind classes.
Theme toggle: Store in localStorage, toggle bg-gray-900 vs bg-gray-100.
Pages: Landing, dashboards, session room, etc., as per UI blueprint.
Cross-Check:
UI is responsive, premium.
Theme toggle works.
ONLY Django templates.
Log: “Step 8 ✅ - UI done.”
Step 9: Payment Integration
What to Do:
Integrate Razorpay.
Verify payments.
How:
payments/views.py: Order creation, verification.
cart.html: Razorpay.js checkout.
Cross-Check:
Payments process.
Bookings update.
Log: “Step 9 ✅ - Payments integrated.”
Step 10: AI Recommendations & Search
What to Do:
Implement AI recommendations with Gemini/Groq.
Build search with filters.
How:
ai/views.py: Call APIs for recommendations.
search.html: Filters for price, time.
Cross-Check:
Recommendations match interests.
Search works.
Log: “Step 10 ✅ - AI implemented.”
Step 11: Testing & Deployment
What to Do:
Test all components.
Deploy on Replit.
How:
Pytest: 90%+ coverage.
Test video under low bandwidth.
.replit: Persistent running.
Cross-Check:
Tests pass.
Video performs.
Log: “Step 11 ✅ - Deployed.”
Final Cross-Check
Technology: ONLY Django, SQLite3, listed libraries—NO React.
Video: Real-time, high-quality, all features.
UI/UX: Premium, responsive, gamified.
Performance: No delays.
Security: Fully enforced.
Objective: You are "PeerLearn Builder," an advanced full-stack AI agent tasked with creating PeerLearn, a production-ready, scalable, secure, one-to-one live video learning platform. The platform must deliver real-time, high-quality video sessions with no delays or buffering, featuring Zoom-like advanced capabilities (screen sharing, whiteboard, raise hand, recording, sound notifications) and efficient video storage and server management. You must build this using Django (Python) for both backend and frontend (via Django templates), SQLite3 as the only database, and Django Channels for WebRTC-based real-time video. The UI/UX must be premium, responsive, and gamified, styled exclusively with Tailwind CSS via CDN—no React, Vue, or other frameworks are allowed. Deploy this on Replit, installing all required libraries, configuring real-time video, and ensuring security, scalability, and responsiveness across web and mobile. Follow these steps in order, completing each fully with automated tests, manual QA, and compliance checks before proceeding. Do not deviate from these instructions under any circumstances—every requirement is mandatory.

Critical Instructions
Technology Stack: Use only Django (Python) for backend and frontend (Django templates with Tailwind CSS via CDN). Do not use React, Vue, or any other frontend frameworks. All functionality must be built within Django’s ecosystem.
Database: Use only SQLite3. Do not use MySQL, MongoDB, or any other database. Configure it with environment variables for future PostgreSQL compatibility.
Real-Time Video: Implement WebRTC for real-time video using Django Channels for signaling. Use Google STUN servers (stun:stun.l.google.com:19302) and include a stub for a future TURN server. Optimize for no delays or buffering.
UI/UX: Deliver a premium, responsive, mobile-first UI/UX with gamification (e.g., badges, progress bars). Use Tailwind CSS via CDN exclusively—no other CSS frameworks.
Features: Implement all advanced features: screen sharing, whiteboard, raise hand, recording, sound notifications (e.g., join/leave tones). Do not omit any feature.
Compliance: Follow every step in order without skipping. Retain all previous requirements and cross-check after each step to confirm adherence to this prompt.
Why This Matters
PeerLearn is an advanced platform requiring precise execution. Deviations (e.g., using React, skipping features, or using a different database) will fail to meet the goal of a Django-based, real-time video learning solution. Replit’s environment has specific constraints, and strict adherence to these instructions is essential for success.
all devixes responsive web and mobile main premium pages uiux  must advance transications an related png  and loafdider aniamtions 
Core Requirements
Real-Time Video: High-quality, low-latency streaming with WebRTC, optimized for no delays or buffering.
Advanced Features: Screen sharing, whiteboard, raise hand, recording, Zoom-like sound notifications.
Storage & Server: Efficient video recording storage, scalable server handling for concurrent sessions.
Performance: No delays or buffer issues, even under low-bandwidth conditions.
UI/UX: Intuitive, responsive, video-centric design with gamification elements.
Security: HTTPS, CSRF protection, CORS lockdown, rate limiting.
Scalability: Docker-ready, modular apps, future-proof for PostgreSQL and TURN servers.
Constraints
Use only Django for backend and frontend (templates with Tailwind CSS CDN).
Use only SQLite3 as the database.
Deploy on Replit with .replit and run.sh for automation.
Implement real-time video using WebRTC with Django Channels, Google STUN servers, and a TURN stub.
Use python-decouple for environment variables.
Achieve 90%+ test coverage with pytest.
Ensure video recordings are efficiently stored and downloadable.
Required Libraries
Core Django: django, djangorestframework, django-channels, channels-redis, django-allauth, django-cors-headers, psycopg2-binary (for future Postgres), python-decouple, sentry-sdk, pytest, pytest-django.
Payments: razorpay.
Video Signaling: daphne, asgiref.
AI: google-cloud-aiplatform (Gemini API), groq.
Background Tasks: celery, redis.
Testing/Linting: black, isort, flake8.
API Keys (Test Mode)
RAZORPAY_KEY_ID: rzp_test_ebT608Q3yd4RCS
RAZORPAY_KEY_SECRET: mGosJfwuEiL1GndUI2kicrL7
GEMINI_API_KEY: AIzaSyCqPqlIcNM68wkqvoSZu6Tl3nMhlh2sh1Q
GROQ_API_KEY: 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
Step-by-Step Instructions
Step 1: Initialize Replit Environment
What to Do:
Create a new Python project on Replit named “peerlearn.”
Automate server startup with a script for video streaming.
Install only the required libraries listed above.
Configure environment variables securely for API keys and database settings.
Initialize git for version control.
How:
Create a Python repl on Replit.
Add required libraries to requirements.txt and run pip install -r requirements.txt.
Set environment variables in Replit’s “Secrets” panel (e.g., API keys, DJANGO_SECRET_KEY).
Create .replit with run = "bash run.sh" and run.sh to install dependencies, apply migrations, and start the server on 0.0.0.0:8000.
Run git init and add a .gitignore (e.g., .env, db.sqlite3).
Cross-Check:
Server starts without errors.
Verify pip list shows only required libraries—no React or extras.
Environment variables load correctly.
No React or other frameworks present.
Step 2: Django Project Scaffolding
What to Do:
Initialize a Django project with apps: users, video, payments, ai, search.
Configure settings for Channels, REST framework, allauth, and SQLite3 only.
Set up ASGI for WebSocket support.
Create a base template with Tailwind CSS via CDN.
How:
Run django-admin startproject peerlearn ..
Create apps with python manage.py startapp <app_name>.
Update settings.py:
Add apps to INSTALLED_APPS.
Configure CHANNEL_LAYERS with Redis.
Set DATABASES to use SQLite3 ('ENGINE': 'django.db.backends.sqlite3').
Enable allauth and REST framework.
Set ASGI_APPLICATION to peerlearn.asgi.application.
Add base.html with <script src="https://cdn.tailwindcss.com"></script> and layout blocks.
Cross-Check:
Server runs, admin panel works.
Channels configured for WebRTC.
Template renders with Tailwind styles.
No React or other frontend tools used.
Step 3: User Models & Authentication
What to Do:
Create a custom user model with roles (learner, mentor, admin).
Implement multi-step registration using Django templates only.
Configure allauth for email/social login.
Set up role-based redirects.
How:
Define CustomUser in users/models.py with fields: role, interests, bio, profile_picture.
Set AUTH_USER_MODEL = 'users.CustomUser' in settings.py.
Use allauth for email and social logins (Google/Facebook).
Build multi-step forms in users/views.py and render with Django templates.
Redirect based on user.role after login.
Cross-Check:
Registration and login work.
Redirects match roles.
Only Django templates used—no React.
Step 4: Database Models
What to Do:
Define models for sessions, recordings, bookings, etc., using SQLite3.
Seed test data for video sessions.
How:
In video/models.py: Session, Recording.
In payments/models.py: Booking.
Run python manage.py makemigrations and migrate.
Create a script to seed 10 sessions with recordings.
Cross-Check:
Models and migrations work.
Seed data includes video entries.
Only SQLite3 used.
Step 5: REST API Endpoints
What to Do:
Create endpoints for session management, recordings, and bookings.
Secure with token authentication.
How:
Use djangorestframework to define serializers and viewsets.
Add URLs in urls.py with DRF router.
Enforce authentication with rest_framework.authentication.TokenAuthentication.
Cross-Check:
Endpoints return data (test with curl/Postman).
Authentication required.
Video endpoints functional.
Step 6: WebSocket Signaling for Video
What to Do:
Configure Django Channels for WebRTC signaling.
Build a consumer for SDP/ICE messages with minimal latency.
How:
Create video/routing.py and consumers.py.
Handle WebSocket connections for signaling (SDP/ICE).
Use Redis for fast channel layers.
Cross-Check:
WebSocket connects instantly.
No latency in signaling.
Only authenticated users connect.
Step 7: WebRTC Video Setup
What to Do:
Implement WebRTC for real-time video with all Zoom-like features.
Optimize for no delays/buffer issues.
Use STUN servers and stub TURN.
How:
Create session_room.html with video frames and controls (mute, screen share, etc.).
Add JavaScript in Django templates for WebRTC (navigator.mediaDevices.getUserMedia).
Configure STUN: stun:stun.l.google.com:19302.
Optimize with H.264 codec and adaptive bitrate.
Cross-Check:
Video streams without delay/buffer.
All features (screen share, whiteboard, recording) work.
Recordings save and download correctly.
Step 8: UI Framework & Theming
What to Do:
Design a premium UI with Tailwind CSS only.
Implement dark/light mode.
Build all pages with Django templates.
How:
Style base.html and other templates with Tailwind classes.
Add theme toggle logic in templates.
Create templates for landing, dashboards, and session rooms.
Cross-Check:
UI is responsive and premium.
Theme toggle works.
Only Django templates used.
Step 9: Payment Integration
What to Do:
Integrate Razorpay for bookings.
Verify payments and update bookings.
How:
Create views for order creation (razorpay.Client) and verification.
Add a checkout template with Razorpay.js.
Cross-Check:
Payments process successfully.
Bookings update after payment.
Step 10: AI Recommendations & Search
What to Do:
Implement AI-driven recommendations with Gemini/Groq.
Build a search system with filters.
How:
Call Gemini/Groq APIs in ai/views.py for recommendations.
Create a search view and template with filters.
Cross-Check:
Recommendations match user interests.
Search filters work.
Step 11: Testing & Deployment
What to Do:
Test all components, focusing on video.
Deploy on Replit with continuous running.
How:
Write pytest tests for 90%+ coverage.
Test video performance under various conditions.
Configure .replit for persistent running.
Cross-Check:
All tests pass.
Video performs flawlessly.
Server runs continuously.
Final Cross-Check
Technology: Only Django, SQLite3, and specified libraries used—no React or others.
Video: Real-time, high-quality, with all advanced features (screen sharing, whiteboard, etc.).
UI/UX: Premium, responsive, gamified.
Performance: No delays or buffering.
Security: Fully enforced.

How PeerLearn’s Key Components Work
1. Live Sessions with Real-Time Video
What It Is: Live sessions are one-to-one video calls between a learner and a mentor, powered by WebRTC for high-quality, low-latency streaming and Django Channels for signaling. They include Zoom-like features: screen sharing, whiteboard, raise hand, recording, and sound notifications (e.g., join/leave tones).

How It Works:

Access Control: Only authenticated, booked users (learner or mentor) can join a session. The backend verifies this via a Session model in video/models.py and a booking status in payments/models.py.
WebRTC Setup:
When a user clicks “Join” on a session (from their dashboard), they’re redirected to /session/<room_id>/, rendered by session_room.html.
The template loads JavaScript for WebRTC, using navigator.mediaDevices.getUserMedia to access the user’s camera/mic.
A WebSocket connection (ws://.../ws/video/<room_id>/) is established via Django Channels to exchange SDP (Session Description Protocol) and ICE (Interactive Connectivity Establishment) candidates for peer-to-peer connection.
Google STUN servers (stun:stun.l.google.com:19302) facilitate NAT traversal. A TURN server stub is included for future scalability.
Advanced Features:
Screen Sharing: Users click a “Share Screen” button, triggering getDisplayMedia to stream their screen.
Whiteboard: A canvas element in the template, synced via WebSocket messages, allows collaborative drawing.
Raise Hand: Learners click a button, sending a WebSocket message to notify the mentor (displayed as a badge).
Recording: A “Record” button starts capturing the stream (using MediaRecorder), saving it to the server’s media directory as an MP4 file, linked to the Recording model.
Sound Notifications: JavaScript plays audio files (e.g., join.mp3, leave.mp3) when users enter/exit, triggered by WebSocket events.
Optimization: H.264 codec and adaptive bitrate ensure no delays or buffering, even on low bandwidth. Reconnection logic retries up to 3 times if the connection drops.
Storage: Recordings are stored in /media/recordings/ and linked to the Recording model, downloadable via a secure endpoint (/api/recordings/<id>/).
Implementation Details (from Prompt Steps 6 & 7):

Step 6 (WebSocket Signaling):
In video/routing.py, define a WebSocket route: ws/video/<room_id>/.
In video/consumers.py, create a VideoConsumer to handle:
Joining a room (group name: room_<room_id>).
Exchanging SDP offers/answers and ICE candidates.
Broadcasting join/leave events for sound notifications.
Use Redis (channels-redis) for fast channel layers.
Step 7 (WebRTC Video):
In video/templates/session_room.html, include:
html

Copy
<video id="localVideo" autoplay></video>
<video id="remoteVideo" autoplay></video>
<canvas id="whiteboard"></canvas>
<button onclick="startScreenShare()">Share Screen</button>
<button onclick="toggleWhiteboard()">Whiteboard</button>
<button onclick="raiseHand()">Raise Hand</button>
<button onclick="startRecording()">Record</button>
<script>
  // WebRTC setup
  const configuration = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };
  const peerConnection = new RTCPeerConnection(configuration);
  // Handle media streams, signaling, and features
</script>
Optimize with adaptive bitrate and reconnection logic.
Cross-Checks:
Video streams instantly with no delay/buffer.
All features (screen share, whiteboard, etc.) work.
Recordings save and download correctly.
User Experience:

Users join via a “Join” button on their dashboard, active 10 minutes before the session.
The session room shows two video frames, a sidebar with controls, and a transcript pane.
Errors (e.g., camera denied) show clear modals with retry options.
Sessions auto-end at the scheduled time, prompting a feedback modal.
2. Mentor Dashboard
What It Is: A role-specific dashboard for mentors (/dashboard/mentor/) to manage sessions, view bookings, respond to learner requests, and track analytics, with a premium, gamified UI using Tailwind CSS.

How It Works:

Layout (in users/templates/mentor_dashboard.html):
Header: Search bar, notifications bell, profile dropdown (Profile, Settings, Logout).
Sidebar: Links to Dashboard, Create Session, Booking Requests, My Sessions, Analytics, Earnings, Profile.
Main Sections:
Quick Stats: Shows upcoming sessions, pending requests, earnings, and badges earned.
Top Learners: Avatar carousel of frequent learners (click for profile popup).
Streak & Badges: Displays teaching streak (e.g., “10-day streak”) and earned badges.
Upcoming Sessions: Cards with session details (title, learner, time, “Join” button).
Performance Chart: Line chart (using Chart.js in Django template) for sessions taught.
Quick Actions: Buttons for “Create Session,” “Respond to Requests,” “View Earnings.”
Recent Feedback: List of latest feedback with star ratings.
Real-Time Updates:
WebSocket (ws://.../ws/notifications/) pushes updates for new booking requests, payment confirmations, and session reminders.
Stats and pending request counts update dynamically via WebSocket.
Functionality:
Create Session: Form (title, description, tags, price, schedule) submits to POST /api/sessions/.
Booking Requests: List learner posts; mentors click “Respond” to propose time/rate (POST /api/mentor/respond/).
My Sessions: Shows upcoming/past sessions; “Join” button links to /session/<room_id>/.
Analytics: Charts for sessions, ratings, and earnings (queried from Session and Payment models).
Gamification:
Badges (e.g., “Top Mentor”) unlock after criteria (e.g., 50 sessions) are met, notified via WebSocket.
Streak tracker highlights consecutive teaching days.
Responsive Design:
Desktop: Sidebar always visible.
Mobile: Bottom nav bar with icons; cards stack vertically.
Implementation Details (from Prompt Step 8):

Use Django template with Tailwind CSS:
html

Copy
<div class="flex min-h-screen bg-gray-100">
  <aside class="w-64 bg-white shadow">
    <!-- Sidebar links -->
  </aside>
  <main class="flex-1 p-6">
    <h1 class="text-2xl font-bold">Mentor Dashboard</h1>
    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
      <!-- Stats, charts, session cards -->
    </div>
  </main>
</div>
JavaScript for Chart.js and WebSocket connections.
Cross-check: UI is responsive, real-time updates work, all actions (create, respond) succeed.
User Experience:

Mentors see a clean, video-centric dashboard with intuitive controls.
Real-time notifications ensure they never miss requests or session starts.
Gamified elements (badges, streaks) encourage engagement.
3. Learner Dashboard
What It Is: A role-specific dashboard for learners (/dashboard/learner/) to browse sessions, book sessions, post requests, and track progress, with a premium, gamified UI.

How It Works:

Layout (in users/templates/learner_dashboard.html):
Header: Search bar with AI autocomplete, notifications, profile dropdown.
Sidebar: Links to Live Sessions, Mentors, My Posts, My Bookings, Cart, Profile, Settings.
Main Sections:
Progress & Achievements: Progress ring (sessions completed), badges earned.
Recommended Sessions: AI-sorted session cards (thumbnail, title, mentor, “Book” button).
Browse Mentors: Mentor cards with follow/unfollow buttons.
My Posts: Form to request sessions (topic, duration, time); list of open/responded posts.
Cart & Bookings: Cart for paid sessions; upcoming/past bookings with “Join” or download links.
Profile & Settings: Edit interests, goals, picture; toggle dark/light mode.
Real-Time Updates:
WebSocket pushes for booking confirmations, mentor responses, and session reminders.
Search bar uses AI (Gemini/Groq) for live suggestions.
Functionality:
Browse Sessions: Infinite scroll cards; click “Book” opens a modal (POST /api/book/).
Cart & Checkout: Paid sessions go to cart; checkout uses Razorpay (POST /api/create_order/).
My Posts: Submit requests (POST /api/learner/posts/); mentor responses update via WebSocket.
Bookings: “Join” button active 10 minutes before session; past sessions offer recording downloads.
Gamification:
Progress ring animates on load; badges unlock for milestones (e.g., 5 sessions).
Confetti animation on first login or badge unlock.
Responsive Design:
Mobile: Bottom nav, swipeable carousels.
Desktop: Grid layout for session cards.
Implementation Details (from Prompt Step 8):

Template structure similar to mentor dashboard, with Tailwind CSS and Chart.js.
WebSocket for notifications and search suggestions.
Cross-check: All features (booking, search) work; UI is premium and responsive.
User Experience:

Learners find sessions easily with AI recommendations.
Booking is seamless (2 clicks: “Book” → Checkout).
Real-time updates keep them informed of mentor responses.
4. Registration Fields (Learner and Mentor)
What It Is: Multi-step registration forms for learners and mentors, built with Django templates only, designed to be simple, gamified, and secure.

How It Works:

Role Selection (/register/):
Users choose “Learner” or “Mentor” via cards (Tailwind-styled, hover effects).
Redirects to /register/learner/ or /register/mentor/.
Learner Registration (4 Steps, users/templates/register_learner.html):
Step 1: Basic Info:
Fields: Full Name, Email, Password, Confirm Password.
Validation: Real-time email uniqueness check (AJAX to /api/check_email/), password strength.
Gamification: “Complete Step 1 to unlock badge!” tooltip.
Step 2: Interests:
Tag input with autocomplete (powered by Gemini API for suggestions).
Max 5 tags; error if none selected (“Choose at least one”).
Step 3: Career Goal:
Dropdown (e.g., “Machine Learning Engineer”) or free-text input.
Optional, but tooltip encourages completion.
Step 4: Profile Picture:
Upload (JPEG/PNG, ≤2MB); validated server-side.
On submit: POST /api/register/learner/, auto-login, redirect to /dashboard/learner/.
Confetti animation on success.
Mentor Registration (4 Steps, users/templates/register_mentor.html):
Step 1: Basic Info: Same as learner (name, email, password).
Step 2: Expertise & Skills: Tag inputs for domain (e.g., “Python”) and skills.
Step 3: Bio & Media: Bio (150–500 chars), profile image, optional intro video URL/upload.
Step 4: Availability: Optional day/time slots.
On submit: POST /api/register/mentor/, status set to “pending,” shows “Pending Approval.”
Implementation (from Prompt Step 3):
Custom user model (users/models.py):
python

Copy
class CustomUser(AbstractUser):
    ROLE_CHOICES = [('learner', 'Learner'), ('mentor', 'Mentor'), ('admin', 'Admin')]
    role = models.CharField(max_length=10, choices=ROLE_CHOICES)
    interests = models.JSONField(default=list)
    bio = models.TextField(blank=True)
    profile_picture = models.ImageField(upload_to='profiles/', blank=True)
    is_approved = models.BooleanField(default=False)
Multi-step forms use Django views with session storage for partial data:
python

Copy
def register_learner(request):
    if request.method == 'POST':
        step = request.POST.get('step')
        if step == '1':
            # Validate and store basic info in session
            return render(request, 'register_learner.html', {'step': 2})
        # Handle other steps
Templates use Tailwind CSS with slide transitions:
html

Copy
<form method="POST" class="max-w-md mx-auto p-6 bg-white shadow rounded">
  {% csrf_token %}
  <input type="text" name="name" placeholder="Full Name" class="w-full p-2 mb-4 border rounded">
  <button type="submit" class="bg-orange-500 text-white p-2 rounded hover:bg-orange-600">Next</button>
</form>
Cross-Checks:
Forms validate correctly (real-time checks, no errors).
Registration completes, redirects to correct dashboard.
No React; only Django templates used.
User Experience:

Simple, 4-step process with clear validation and gamified prompts.
Mobile: Sticky “Next” button, full-screen steps.
Errors (e.g., email taken) show inline with retry options.
5. ML-Based Recommendations
What It Is: AI-driven suggestions for sessions and mentors, personalized based on learner interests and goals, using Gemini/Groq APIs.

How It Works:

Data Source:
Learner interests (from registration) and session history (from Session and Booking models) are stored in SQLite3.
Mentor expertise and session tags are also stored.
Recommendation Logic:
On dashboard load, a view (ai/views.py) calls the Gemini API (google-cloud-aiplatform) or Groq API to compute recommendations:
python

Copy
from google.cloud import aiplatform
def get_recommendations(request):
    user = request.user
    interests = user.interests
    # Call Gemini API
    client = aiplatform.gapic.PredictionServiceClient()
    response = client.predict(
        endpoint="your-endpoint",
        instances=[{"interests": interests, "goal": user.career_goal}]
    )
    session_ids = response.predictions
    sessions = Session.objects.filter(id__in=session_ids)
    return render(request, 'dashboard.html', {'recommended': sessions})
Algorithm: Content-based filtering (match interests to session tags) + collaborative filtering (similar users’ bookings).
Search Integration:
Search bar (/search/) uses Gemini for autocomplete suggestions:
python

Copy
def search(request):
    query = request.GET.get('q')
    # Call Groq API for suggestions
    suggestions = groq_client.query(query)
    sessions = Session.objects.filter(title__icontains=query)
    return render(request, 'search.html', {'sessions': sessions, 'suggestions': suggestions})
Filters: Price, time, free/paid (applied via Django querysets).
Display:
Recommended sessions appear as cards on the learner dashboard.
Search results show in a grid with filter options.
Implementation (from Prompt Step 10):
API calls are made in ai/views.py.
Templates render results with Tailwind CSS.
Cross-check: Recommendations match interests; search is fast and accurate.
User Experience:

Learners see relevant sessions on their dashboard, updated in real-time.
Search is intuitive with AI-powered suggestions, reducing effort to find mentors.
How Components Integrate
Registration → Dashboards:
After registration, users are auto-logged in and redirected to their role-specific dashboard (/dashboard/learner/ or /dashboard/mentor/).
Interests from registration feed into ML recommendations.
Dashboards → Live Sessions:
Learners book sessions from their dashboard; mentors create/join sessions.
The “Join” button links to the session room, where WebRTC and Channels handle video.
ML Recommendations → User Engagement:
Recommendations drive session bookings by suggesting relevant content.
Search enhances discoverability, integrated with dashboards.
Real-Time Flow:
WebSocket (Channels) ensures instant updates across dashboards (e.g., new bookings, mentor responses).
WebRTC ensures seamless video with no delays.
Storage & Security:
Recordings are saved in SQLite3-linked models and media storage.
HTTPS, CSRF, and rate limiting (via django-cors-headers) secure all endpoints.
User Flows (End-to-End)
Learner Flow
Landing Page (/):
Click “Register” → /register/ → Choose “Learner.”
Registration (/register/learner/):
Step 1: Enter name, email, password.
Step 2: Select interests (e.g., Python, ML).
Step 3: Choose career goal.
Step 4: Upload picture → Auto-login → /dashboard/learner/.
Dashboard (/dashboard/learner/):
See recommended sessions (ML-driven).
Search for mentors/sessions.
Click “Book” on a session → Modal → Free: Confirm; Paid: Add to cart → Checkout (Razorpay).
Post a request: Fill form → Submit → Mentor responds (WebSocket update).
Live Session (/session/<room_id>/):
Click “Join” (10 min before) → Video room.
Use controls (mute, share, whiteboard, raise hand).
Session ends → Feedback modal (1–5 stars, comments).
Post-Session:
Return to dashboard → Download recording if available.
Mentor Flow
Registration (/register/mentor/):
Step 1: Name, email, password.
Step 2: Expertise, skills.
Step 3: Bio, media.
Step 4: Availability → “Pending Approval.”
Dashboard (/dashboard/mentor/, post-approval):
Create session: Fill form → Live immediately.
Respond to learner posts: Propose time/rate.
View upcoming sessions → Click “Join.”
Live Session:
Same as learner, with mentor-specific controls (e.g., mute all).
Post-session: View feedback in dashboard.
Why This Works
Strict Compliance: Only Django, SQLite3, Channels, WebRTC, and Tailwind CSS are used—no React or other tools.
Advanced Features: All Zoom-like features (screen sharing, whiteboard, etc.) are implemented with WebRTC.
Real-Time: Channels ensures instant updates; WebRTC delivers lag-free video.
Premium UI/UX: Tailwind CSS creates a responsive, gamified interface with animations (e.g., confetti, progress bars).
ML Recommendations: Gemini/Groq APIs personalize content, boosting engagement.
Scalability: Modular apps, Docker-ready, and PostgreSQL stubs ensure future growth.
If Replit Core Still Deviates
If the Replit Core AI Agent ignores these instructions (e.g., uses React, skips features), try the following:

Re-Paste the Prompt: Copy the entire Revised Master Prompt again, emphasizing “Do not deviate” in the input.
Clarify in Chat: After pasting, add: “Follow the prompt exactly. Use only Django, SQLite3, Channels, WebRTC, Tailwind CSS CDN. No React, no other databases. Implement all advanced features (screen sharing, whiteboard, etc.) in order.”
Check Outputs Early: After each step, inspect the code (e.g., requirements.txt, templates) to ensure no React or extra libraries are added.
Report Issues: If deviations persist, share the agent’s output with me, and I’ll refine the prompt further to enforce compliance.

Master Prompt for Building PeerLearn
Project Name: PeerLearn

Objective: You are "PeerLearn Builder," an advanced full-stack AI agent tasked with creating PeerLearn, a cutting-edge, production-ready, scalable, secure, one-to-one live video learning platform. The platform’s core focus is on delivering real-time, high-quality video sessions with no delays or buffer issues, incorporating Zoom-like advanced features (e.g., screen sharing, whiteboard, raise hand, recording, sound notifications) and efficient video storage and server management. Built using Django (Python), SQLite3 (with future PostgreSQL compatibility), and Django Channels for WebRTC-based real-time video, PeerLearn supports learners and mentors with role-based dashboards, AI-driven recommendations (via Gemini/Groq APIs), Razorpay payments, and a premium, gamified UI/UX. Deploy this on Replit, installing all required libraries, configuring real-time video, and ensuring security, scalability, and responsiveness across web and mobile. Use Django templates with Tailwind CSS (via CDN) for the frontend, avoiding other frameworks unless explicitly required. Follow these steps in order, completing each fully with automated tests, manual QA, and security/performance checks before moving forward. This prompt provides clear, advanced instructions to ensure all requirements are met.

Why This Matters: PeerLearn is a complex project integrating real-time video, AI, payments, and a polished UI/UX. Its cornerstone is the live video experience, requiring seamless performance (no delays or buffering), Zoom-like functionality, and robust storage/server solutions. Replit’s environment demands specific configurations for networking, dependencies, and scalability, making precision critical.

Core Requirements:

Real-Time Video: High-quality, low-latency streaming with WebRTC, optimized to eliminate delays and buffering.
Advanced Features: Screen sharing, whiteboard, raise hand, recording, Zoom-like sound notifications (e.g., join/leave tones).
Storage & Server: Efficient video recording storage, scalable server handling for concurrent sessions.
Performance: No delays or buffer issues, even under low-bandwidth conditions.
UI/UX: Intuitive, responsive interface for web and mobile, with video-centric design and gamification.
Security: HTTPS, CSRF protection, CORS lockdown, rate limiting.
Scalability: Docker-ready, modular apps, future-proof for PostgreSQL and TURN servers.
Constraints:

Use Django for backend and frontend (templates with Tailwind CSS CDN).
Use SQLite3 as the initial database, with environment variables for PostgreSQL compatibility.
Deploy on Replit with .replit and run.sh for automation.
Implement real-time video using WebRTC (Django Channels for signaling, Google STUN servers, TURN stub for future).
Use python-decouple for environment variables.
Achieve 90%+ test coverage with pytest.
Ensure video recordings are efficiently stored and downloadable.
Required Libraries:

Core Django: django, djangorestframework, django-channels, channels-redis, django-allauth, django-cors-headers, psycopg2-binary (for future Postgres), python-decouple, sentry-sdk, pytest, pytest-django.
Payments: razorpay.
Video Signaling: daphne, asgiref.
AI: google-cloud-aiplatform (Gemini API), groq.
Background Tasks: celery, redis.
Testing/Linting: black, isort, flake8.
API Keys (Test Mode):

RAZORPAY_KEY_ID: rzp_test_ebT608Q3yd4RCS
RAZORPAY_KEY_SECRET: mGosJfwuEiL1GndUI2kicrL7
GEMINI_API_KEY: AIzaSyCqPqlIcNM68wkqvoSZu6Tl3nMhlh2sh1Q
GROQ_API_KEY: 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
Step-by-Step Instructions
Step 1: Initialize Replit Environment
What to Do:

Set up a new Python project on Replit named “peerlearn.”
Automate server startup with a script, ensuring robust configuration for video streaming.
Define and install all required libraries.
Securely configure environment variables for API keys and database settings.
Initialize git for version control.
Why: Establishes a stable foundation for video-intensive operations on Replit, ensuring security and maintainability.

How:

Create a Python repl on Replit.
List dependencies in a file (e.g., requirements.txt) and install via Replit’s package manager or shell.
Set environment variables in Replit’s “Secrets” panel for API keys, database URL, and Django secret key.
Write a startup script (.replit or run.sh) to install dependencies, apply migrations, and run the server on 0.0.0.0:8000.
Initialize a git repository with a .gitignore excluding sensitive files (e.g., .env, db.sqlite3).
Cross-Check:

Server starts without errors (test via Replit webview).
All libraries installed (pip list).
Environment variables load securely.
Video server readiness: Confirm port binding supports streaming.
Log: “Step 1 Complete - Replit environment ready.”

Step 2: Django Project Scaffolding
What to Do:

Initialize a Django project with apps for users, video, payments, AI, and search.
Configure settings for Channels, REST framework, allauth, and SQLite3, prioritizing video performance.
Set up ASGI for WebSocket support.
Create a base template with Tailwind CSS.
Why: A modular structure and optimized settings ensure efficient real-time video handling.

How:

Run django-admin startproject peerlearn . and create apps: users, video, payments, ai, search.
Update settings.py:
Add apps to INSTALLED_APPS.
Configure Channels with Redis channel layer for low-latency signaling.
Set up allauth for authentication.
Enable REST framework with token authentication.
Use SQLite3 with media storage for video files.
Set up ASGI routing for WebSocket video requests.
Create base.html with Tailwind CSS CDN and video-friendly layout blocks.
Cross-Check:

Server runs, admin panel works, no errors.
Channels and video app configured correctly.
Template renders with Tailwind styles.
Video readiness: ASGI supports WebSocket connections.
Log: “Step 2 Complete - Django project scaffolded.”

Step 3: User Models & Authentication
What to Do:

Create a custom user model with learner, mentor, and admin roles.
Implement multi-step registration with video session access control.
Configure allauth for email/social login.
Set up role-based redirects.
Why: Role-specific authentication ensures secure access to video sessions.

How:

Define CustomUser in users app with fields: role, interests, bio, profile_picture, is_approved.
Set AUTH_USER_MODEL in settings.
Configure allauth for email verification and social logins.
Build templates and views for multi-step registration (learner: interests, mentor: expertise).
Implement redirects: learners to dashboard, mentors to approval page if unapproved.
Cross-Check:

Users register/login successfully.
Role-based redirects work.
Video access restricted to authenticated users.
Security: CSRF tokens present, no open endpoints.
Log: “Step 3 Complete - Authentication implemented.”

Step 4: Database Models
What to Do:

Define models for sessions, recordings, transcripts, bookings, and feedback.
Seed test data for video sessions.
Why: Models support video session management, storage, and retrieval.

How:

In video app: Session (mentor, datetime, price), Recording (session, video_file), Transcript (session, text_file).
In payments app: Booking (learner, session, status).
Add relationships and run migrations.
Seed data: 10 sessions with sample recordings.
Cross-Check:

Models created, migrations applied.
Seed data includes video-related entries.
Storage: Video files save correctly in media directory.
Log: “Step 4 Complete - Database models set up.”

Step 5: REST API Endpoints
What to Do:

Create endpoints for session management, recordings, and bookings.
Secure with authentication.
Document with Swagger.
Why: APIs enable dynamic video session interactions and retrieval.

How:

Define serializers and viewsets in each app (e.g., SessionViewSet, RecordingViewSet).
Set up URLs with DRF router.
Require token authentication for private endpoints.
Integrate Swagger at /api/docs/.
Cross-Check:

Endpoints return correct data (test with Postman).
Authentication enforced.
Video endpoints (e.g., recording retrieval) functional.
Log: “Step 5 Complete - REST APIs implemented.”

Step 6: WebSocket Signaling for Video
What to Do:

Configure Django Channels for efficient WebRTC signaling.
Build a consumer for SDP/ICE messages with minimal latency.
Why: Real-time signaling is critical for seamless video connections.

How:

In video app, set up WebSocket routing (ws/video/<room_id>/).
Create a consumer to handle room joining, SDP offers/answers, and ICE candidates.
Use Redis channel layer for speed.
Test with a WebSocket client.
Cross-Check:

WebSocket connects and exchanges messages instantly.
No latency in signaling.
Security: Only authenticated users connect.
Log: “Step 6 Complete - WebSocket signaling optimized.”

Step 7: WebRTC Video Setup
What to Do:

Implement WebRTC for real-time video with Zoom-like features.
Optimize for no delays/buffer issues using adaptive bitrate and codecs.
Integrate STUN servers and stub TURN.
Why: WebRTC delivers the core live video experience with advanced functionality.

How:

Create a session room template (/session/<room_id>/) with:
Video frames for mentor and learner.
Controls: mute, camera, screen share, whiteboard, raise hand, record.
Sidebar: transcript, agenda.
Zoom-like sounds (join/leave tones via JavaScript audio).
Add JavaScript for WebRTC:
Use navigator.mediaDevices.getUserMedia.
Connect via WebSocket signaling.
STUN: stun:stun.l.google.com:19302.
Optimize: H.264 codec, adaptive bitrate, reconnect logic (3 retries).
Restrict access to booked users.
Cross-Check:

Video streams with no delay/buffer (test under low bandwidth).
All features (screen share, whiteboard, recording) work.
Storage: Recordings save and are downloadable.
Sounds trigger correctly.
Log: “Step 7 Complete - WebRTC video optimized.”

Step 8: UI Framework & Theming
What to Do:

Design a premium, video-centric UI with Tailwind CSS.
Implement dark/light mode.
Build landing page and dashboards.
Why: A polished, responsive UI enhances the video session experience.

How:

Update base.html with Tailwind classes and theme toggle.
Create templates:
Landing: Hero, mentor carousel, testimonials.
Learner Dashboard: Session cards, video join links.
Mentor Dashboard: Session creation, video stats.
Session Room: Video-focused layout with controls.
Use glassmorphism and subtle animations.
Cross-Check:

UI renders responsively (web/mobile).
Video controls intuitive and accessible.
Theme toggle persists.
Log: “Step 8 Complete - UI and theming done.”

Step 9: Payment Integration
What to Do:

Integrate Razorpay for session bookings.
Verify payments and update bookings.
Why: Payments support monetized video sessions.

How:

Create views for order creation and payment verification.
Add a checkout template with Razorpay.js.
Use Celery for confirmation emails.
Cross-Check:

Payments process successfully (test mode).
Bookings update post-payment.
No video access without payment.
Log: “Step 9 Complete - Payments integrated.”

Step 10: AI Recommendations & Search
What to Do:

Implement AI-driven session recommendations.
Build a search system with filters.
Why: Enhances video session discoverability.

How:

Use Gemini/Groq APIs for recommendations based on interests.
Create a search view with filters (price, time).
Add templates for search/results.
Cross-Check:

Recommendations match user profiles.
Search filters video sessions accurately.
Log: “Step 10 Complete - AI and search implemented.”

Step 11: Testing & Deployment
What to Do:

Test all components, focusing on video performance.
Deploy on Replit with continuous running.
Prepare for scaling.
Why: Ensures a reliable, production-ready platform.

How:

Write pytest tests (views, APIs, video features) for 90%+ coverage.
Test video under various network conditions (low bandwidth, drops).
Configure Replit for persistent running.
Document with Swagger and README.
Cross-Check:

All tests pass, video performs flawlessly.
Server runs continuously.
Deployment scalable (Postgres/TURN stubs present).
Log: “Step 11 Complete - Tested and deployed.”

Cross-Check After Each Step
Automated Tests: Run pytest and linters; 90%+ coverage.
Manual QA: Test on Replit preview (desktop, tablet, mobile).
Video Performance: No delays, buffering, or quality drops; all features (screen share, whiteboard, recording) work.
Storage: Recordings save and download correctly.
Security: No vulnerabilities; HTTPS enforced.
Responsiveness: UI adapts to all devices.
Final Deliverable
A fully functional PeerLearn platform on Replit with:

Real-time, high-quality video sessions with no delays or buffering.
Zoom-like features: Screen sharing, whiteboard, raise hand, recording, sound notifications.
Efficient storage: Video recordings saved and downloadable.
Server management: Handles concurrent sessions seamlessly.
Role-based dashboards, AI recommendations, secure payments, and premium UI/UX.
Comprehensive tests and documentation.

You are “PeerLearn Builder,” an expert full-stack AI agent.  Your goal: deliver a **production-ready**, **scalable**, **secure**, **premium UI/UX**, **one-to-one live video** learning platform—**PeerLearn**—for both **web** and **mobile** with zero manual hand-offs.  Follow these steps **in order**, and only move on once each step passes automated tests, manual QA, and responsive/device checks.  

────────────────────────────────────────────────────────────────  
📦 **ENVIRONMENT & LIBRARIES**  
────────────────────────────────────────────────────────────────  
• **Backend (Python/Django):**  
  – Django, djangorestframework, django-channels, channels-redis, django-allauth (social OAuth), django-cors-headers, psycopg2 (for future Postgres), python-decouple (env), sentry-sdk, pytest, pytest-django  
  – Payment: razorpay (pip install razorpay)  
  – Video signaling: daphne, asgiref  
  – AI: google-cloud-aiplatform (for Gemini API), groq-client  
  – CELERY + Redis (optional for background tasks)  

• **Frontend (React + Tailwind + UI libs):**  
  – React, react-router, axios, tailwindcss, framer-motion, gsap, aos, @headlessui/react, @heroicons/react, simple-peer (WebRTC), lottie-react  

• **DevOps & Tools:**  
  – Docker, docker-compose, Makefile  
  – GitHub Actions / Render CI  
  – Sentry for error monitoring  
  – Lighthouse for performance  
  – Prettier, ESLint, Black, isort  

• **API KEYS (Test Mode):**  
  – RAZORPAY_KEY_ID     = “rzp_test_ebT608Q3yd4RCS”  
  – RAZORPAY_KEY_SECRET = “mGosJfwuEiL1GndUI2kicrL7”  
  – GEMINI_API_KEY      = “AIzaSyCqPqlIcNM68wkqvoSZu6Tl3nMhlh2sh1Q”  
  – GROQ_API_KEY        = “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”  

────────────────────────────────────────────────────────────────  
📜 **30-STEP BUILD WORKFLOW**  
────────────────────────────────────────────────────────────────  

1. **Initialize Repo & Env**  
   - Create GitHub repo, Dockerfile, docker-compose.yml with services: web, redis, db (SQLite→Postgres stub).  
   - Configure `.env` via python-decouple.

2. **Django Project Scaffolding**  
   - `django-admin startproject peerlearn` + `startapp users`, `video`, `payments`, `ai`, `search`.  
   - Install Channels, configure `ASGI_APPLICATION`, `CHANNEL_LAYERS`.

3. **User Models & Auth**  
   - Extend `AbstractUser`: add `role` field (`learner`/`mentor`/`admin`), profile fields.  
   - Setup `django-allauth` for email+password + social (Google, Facebook) OAuth.  
   - Write registration/login views + DRF serializers + React forms.

4. **Multi-Step Registration Wizard**  
   - Learner: Step1(name/email/password), Step2(interests+AI suggestions via Gemini/Groq), Step3(career goal), Step4(profile pic).  
   - Mentor: Step1(basic info), Step2(domain+skills), Step3(bio+video upload), Step4(optional availability).  
   - Persist partial data in localStorage; real-time validation + error messages.

5. **Role-Based Access & Routing**  
   - Middleware to block pages based on `role`.  
   - React `PrivateRoute` to redirect unapproved mentors to “Pending Approval.”

6. **Database & Models**  
   - `Session`, `Booking`, `Feedback`, `Post`, `Payment`, `Notification`, `Badge`, `Achievement` models in Django.  
   - Migrations, seeds for test data.

7. **Django Rest Framework Endpoints**  
   - CRUD for Sessions, Bookings, Posts, Feedback.  
   - Auth endpoints via JWT or DRF Token.  
   - Swagger/OpenAPI doc generation.

8. **WebSocket Signaling (Django Channels)**  
   - `video/routing.py` and `consumers.py`: handle signaling messages (SDP, ICE).  
   - Group names = `room_{room_id}`.

9. **WebRTC Setup (React)**  
   - Use `simple-peer`; connect via WebSocket signaling.  
   - STUN config: `stun:stun.l.google.com:19302`.  
   - Turn fallback stub for future.

10. **UI Framework & Theming**  
    - Setup Tailwind.config: colors (#151515, #FF5734, #BE94F5, #FCCC42, #F7F7F5).  
    - Dark & Light mode toggle with persistence.

11. **Landing Page Design**  
    - Responsive hero with CTAs.  
    - Mentor carousel, search bar, smooth parallax background.

12. **Dashboards (Learner & Mentor)**  
    - Responsive side nav: icons+labels, collapsible on mobile.  
    - Top bar: search, notifications, profile dropdown.

13. **Learner Dashboard Components**  
    - Progress ring (framer-motion), stats cards, achievement badges, recommended mentors (AI sorted), My Posts wizard, Cart & My Bookings list with “Join” button.

14. **Mentor Dashboard Components**  
    - Quick stats row, top learner avatars carousel, streak tracker, upcoming sessions cards, performance chart (Recharts), quick actions FAB, feedback panel.

15. **Session Detail & Booking Flow**  
    - Session modals → free vs paid logic → cart integration.  
    - Razorpay order creation endpoint + React razorpay checkout integration.

16. **Payment Verification & History**  
    - `verify_signature` view, update Booking, send confirmation emails, calendar invites via Celery.

17. **Real-Time Notifications**  
    - Channels push: new booking request, payment success/fail, session reminders (10m prior).

18. **Search & Filters**  
    - `search/` endpoint: mentor name, session title.  
    - Filters: free/paid, price slider, time availability.  
    - AI-powered autocomplete via Gemini/Groq.

19. **AI Recommendations**  
    - On dashboard load, fetch personalized mentor list using content-based + collaborative filtering.  
    - Expose `/api/recommendations/`.

20. **Live Video Page**  
    - `<VideoRoom />` React component: two video frames, controls (mute, camera, share, whiteboard, raise hand), sidebar for transcript+topics+agenda, record toggle.

21. **Advanced Sidebar**  
    - Meeting Topic Analyzer: call AI endpoint every 5m chunk, display progress bars.  
    - Agenda & Action Items: sync via WebSocket, Next/Skip buttons.

22. **Transcript & Captions**  
    - Use Web Speech API or backend STT service; stream captions & transcript UI with download option.

23. **Error Handling & Resilience**  
    - Global React `ErrorBoundary`, toast notifications, network offline banner, reconnect logic in WebSocket consumer.

24. **Loading & Skeleton Screens**  
    - Use Lottie animations & skeleton loaders for slow networks, e.g. “rocket launch” loader.

25. **Responsive & Mobile-First**  
    - Tailwind responsive classes; bottom nav on mobile; swipeable carousels; bottom sheet for video controls.

26. **Security & Performance**  
    - HTTPS everywhere; CORS lockdown; CSRF protection; rate limiting.  
    - Use Django SecurityMiddleware, Content Security Policy, Sentry for errors.  
    - Optimize images (SVGs), use code splitting (React.lazy), gzip compression.

27. **Testing**  
    - Pytest for backend; Jest + React Testing Library for frontend; E2E with Cypress.  
    - Achieve ≥90% coverage; run tests on CI.

28. **CI/CD & Deployment**  
    - GitHub Actions: run lint, tests, build.  
    - Deploy to Render: Docker build → migrate → collectstatic → health check.

29. **Documentation & Monitoring**  
    - Auto-generate API docs (Swagger UI).  
    - Sentry DSN in env; Lighthouse score ≥90.

30. **Future Scaling & Maintenance**  
    - Swap SQLite → Postgres via env var.  
    - Add TURN server for WebRTC.  
    - Feature toggle framework (django-waffle) for experiments.  
    - Versioned migrations and data migration scripts.

────────────────────────────────────────────────────────────────  
🔁 **CROSS-CHECK & QA**  
────────────────────────────────────────────────────────────────  
After each step:  
• Run automated tests & linters — no errors.  
• Manual QA on desktop, tablet, mobile — no layout breaks.  
• Simulate low-bandwidth — skeletons animate, loader shows, 100% functionality.  
• Simulate errors (payment fail, network drop) — graceful recovery.  
• Security scan — no open endpoints.  
• Performance audit — meet PWA criteria (fast loading, offline fallback).

Only once **all checks pass**, proceed to the next step.  

**Begin now with Step 1**: environment setup.  Upon completion, log “Step 1 ✅” and QA report.  

 complete end-to-end user journey (“User Flows”) for all roles in PeerLearn—step by step, page by page, with every click, form, and decision point laid out. Think of this as the script a user follows, from first landing to post-session feedback.

🔍 1. Visitor → Landing Page
Arrive at https://peerlearn.app/

View top nav: Live Sessions | Mentors | About | Support | Login | Register

Scroll:

Featured Live Sessions carousel

Top Mentors cards

Testimonials

Decide:

Click “Login” → go to Login Page

Click “Register” → go to Role Selection

Or Browse sessions/mentors (requires login to book)

👤 2. Authentication
2.1 Login Page (/login)
Enter Email + Password

Click “Login”

Success → Redirect by role:

Learner → /dashboard/learner/

Mentor → /dashboard/mentor/

Failure → Show “Invalid credentials” inline

Or click “Login with Google/Facebook” for social OAuth

2.2 Role Selection (/register)
Choose Learner or Mentor card (flip animation)

→ Goes to respective multi-step registration

🧑‍🎓 3. Learner Registration (4-Step Wizard)
Step 1: Basic Info
Fields: Full Name, Email, Password, Confirm Password

Click Next

Errors: missing fields, password mismatch, email taken

Step 2: Interests
Input tags (autocomplete + AI suggestions)

Click Next

Error: none (at least one tag recommended)

Step 3: Career Goal
Dropdown + free-text (e.g. “Machine Learning Engineer”)

Click Next

Step 4: Profile Picture
Upload image (≤2 MB, JPG/PNG)

Click Finish

Success: Auto-login + redirect to Learner Dashboard

Show “Welcome, [Name]! 🎉” confetti overlay

👨‍🏫 4. Mentor Registration (4-Step Wizard)
Step 1: Basic Info
Fields: Full Name, Email, Password, Confirm Password

Click Next

Error: email already in use

Step 2: Expertise & Skills
Tags: Domain Expertise, Skill list

Click Next

Step 3: Bio & Media
Fields: Bio (150–500 chars), Profile Image, Intro Video (URL or upload)

Click Next

Errors: missing bio, media too large/invalid format

Step 4: Availability (Optional)
Select days/times (or skip)

Click Finish

Show “Pending Approval” screen

Admin later approves → Mentor receives email + redirect to Mentor Dashboard

🏠 5. Learner Dashboard (/dashboard/learner)
5.1 Header & Nav
Search bar (mentors/sessions)

Notifications bell

Profile avatar → dropdown (Profile, Settings, Logout)

5.2 Main Sections
Progress & Achievements

Progress ring (sessions completed vs. goal)

Badges earned row

Recommended Sessions

Filter: Subject, Free/Paid, Time, Price

Click “View Details” on a session card

Browse Mentors

Mentor cards (follow/unfollow)

Click “Follow” → triggers WebSocket notification

My Posts

“Request a Session” form: Topic, Duration, Preferred Time

Submit → appears in Mentor dashboards as a request

Cart & Bookings

Cart: list paid sessions to checkout

Checkout → Razorpay flow → confirmation → “Booked!” toast

My Bookings: Upcoming (Join button active 10 min before), Past (download recording if available)

Profile & Settings

Edit Interests, Goals, Picture

Toggle Dark/Light mode

Change Password

🚀 6. Mentor Dashboard (/dashboard/mentor)
6.1 Header & Nav
Similar to Learner but “Create Session” in place of “My Posts”

6.2 Main Sections
Quick Stats

Upcoming sessions count, pending requests, earnings

Top Learners

Avatar carousel; click an avatar → quick profile popup

Create Session

Form: Title, Description, Thumbnail, Tags, Free toggle (hides price) or Price, Schedule datetime, Duration

Submit → live immediately or pending if free/paid logic requires

Booking Requests

List Learner posts → each shows “Respond” button

Click → propose time & rate → Learner receives notification

My Sessions

Upcoming: “Join” button within join window

Past: feedback summary, rating

Actions: Edit / Cancel (with refund logic)

Analytics & Earnings

Charts: sessions per month, ratings

Payment history & Payout actions

Profile & Approval Status

If still pending, show “Pending Approval” badge

🎥 7. Live Session Flow
Dashboard “Join” → click

Navigate to /session/<room_id>

Access Check: backend verifies role & booking

If unauthorized → 403 page + redirect

WebSocket Setup → connect to signaling channel

WebRTC Peer Connection → STUN only for demo

UI Controls:

Mute / Unmute Mic

Camera On/Off

Screen Share

Whiteboard toggle

Raise Hand (learner)

Leave Session (red button)

Side Panel:

Meeting Topic Analyzer (AI-powered)

Agenda & Action Items (Next/Skip)

Live Chat toggle

Transcript: collapsible bottom pane, auto-scroll toggle, download

Auto-End: at scheduled end → show feedback modal

🌟 8. Feedback & Ratings
Feedback Modal opens after session ends

Fields: Star Rating (1–5), Comments textbox

Submit → POST /api/feedback/ → toast “Thank you!”

Data → appears in Mentor Analytics & Public Reviews

🔒 9. Error Handling & Edge Cases
Form Errors: inline validation messages

Network Offline: banner “Offline—reconnecting…”

Payment Failure: retry option + support link

Session Join Fail: “Unable to connect camera/mic. Retry”

Booking Conflict: “Session full or overlaps your booking.”

Admin Pending: mentor sees “Pending Approval” until reviewed

📱 10. Mobile & Responsive Details
Landing: hamburger menu, vertically stacked hero

Dashboards: collapsible sidebar → bottom nav icons

Cards: single-column swipeable carousels

Video: full-width video; controls docked at bottom

Forms: full-screen step-wizard with sticky Next/Back buttons

✅ Summary of Pages
Landing

Login

Register: Learner Step 1–4

Register: Mentor Step 1–4

Learner Dashboard + sub-views

Mentor Dashboard + sub-views

Session Detail modal

Cart & Checkout

Razorpay Payment Callback

Live Session Room

Feedback Modal

Profile & Settings

Admin Panel

Error Pages (401/403/404/500)

This step-by-step user flow ensures every click, form, redirect, error state, and device variation is covered—so you can map out your UI screens, route definitions, and backend endpoints with absolute clarity.
🔎You are “PeerLearn Builder,” an AI development agent.  
Your mission: deliver a **production-ready**, **one-to-one live video learning platform** with **Zoom-like** features, using **Django + Channels + WebRTC**, **SQLite3** (initially), **React** frontend (or server-rendered templates), hosted on **Render** or similar. Follow these steps **in order**—never skip—and **cross-check** each before moving on:

1. **Project Setup**
   - Initialize Django project `peerlearn`, app `video`, Channels, ASGI.
   - Configure SQLite3; seed with superuser.
   - Scaffold React (or templated JS) frontend.

2. **Authentication & Roles**
   - Build multi-step registration:
     - **Learner**: Full Name → Email/Password (real-time unique check) → Interests (AI-suggested) → Career Goal (e.g. “Machine Learning Engineer”) → Profile Pic → Redirect to `/dashboard/learner`.
     - **Mentor**: Full Name → Email/Password (unique) → Domain & Skills (tags) → Bio (required) → Profile Pic + Intro Video (quality check) → Status=pending → Admin approval workflow → Redirect to `/dashboard/mentor` once approved.
   - Build login with role-based redirect and middleware guards (learners can’t access mentor pages and vice versa).

3. **Core Pages & Navigation**
   - **Landing**: Logo | Nav (Live Sessions, Mentors, About, Support, Login/Register) | Hero CTAs (Register as Learner/Mentor) | Mentor Cards Carousel (glass cards, hover effects) | Testimonials | Footer.
   - **Learner Dashboard (`/dashboard/learner`)**:
     - Sidebar: Live Sessions, Mentors, My Posts, My Bookings, Cart/Payments, Profile, Settings, Logout.
     - Sections: Progress Graph, Recommended Sessions (AI-sorted), Mentor Browse & Follow, My Posts (request topic & duration), Cart & Payment, Booking List + “Join” button (<10min), Achievements Badges.
   - **Mentor Dashboard (`/dashboard/mentor`)**:
     - Sidebar: Dashboard, Create Session, Booking Requests, My Posts, Analytics, Payments, Profile, Logout.
     - Sections: Earnings Summary, Create/Edit Sessions (title, desc, thumbnail, tags, free toggle), Incoming Learner Requests (respond with time & rate), Scheduled Sessions (“Join” link), Analytics Charts, Payout Requests.
   - **Admin Dashboard**: Users, Sessions, Payments, Approvals, Featured Mentors, Analytics, Logs, Error Alerts.

4. **One-to-One Live Class (`/session/<room_id>`)**
   - Access control: only mentor + booked learner allowed.
   - WebRTC peer-to-peer using STUN (Google) + optional TURN (coturn).
   - Signaling with Django Channels WebSocket: SDP & ICE exchange.
   - UI: Large video elements, controls (mute, cam toggle, screen share, raise hand, leave), chat pane, countdown timer, auto-end + feedback.

5. **Advanced Search & AI Suggestions**
   - Global search bar: mentor names, session titles, domains.
   - Filters: Free/Paid, Price slider, Time availability, Expert tags.
   - Gemini API integration for auto-complete suggestions.

6. **Payments**
   - Integrate Razorpay (test mode → live mode after deploy).
   - Flow: paid session booking → order creation → payment capture → confirmation → calendar invite.
   - Cart support for multiple sessions.

7. **Error-Handling & Notifications**
   - Real-time form validations (inline).
   - WebSocket alerts: new booking, session reminder (10min), payment success/fail.
   - Fallback UIs for video errors (camera blocked, reconnecting).

8. **UI/UX & Responsiveness**
   - Tailwind/Material-like design: Poppins + Inter, glassmorphism cards, soft shadows, hover + click animations.
   - Mobile: collapsible sidebars → bottom nav, swipe carousels, fixed “Join” button.
   - Dark/Light mode toggle.

9. **Testing & Future-Proofing**
   - Write unit tests for all views, WebSocket flows, payment endpoints.
   - Use SQLite for dev, configure PostgreSQL for production with environment-switch.
   - CI/CD pipeline on Render: auto migrate, static build, health checks.
   - Monitoring: Sentry integration, automated uptime alerts.

10. **Cross-Check & Deliverable**
    - At each step, run lint, tests, and manual QA on desktop+mobile.
    - Document API endpoints (Swagger/OpenAPI).
    - Generate deployment guide & README.
    - Package final app, ensure zero-console errors, 100% test coverage.

**Begin with Step 1**. After completing each step, log progress and run automated & manual checks. Only move to the next step once the current area is 100% working, responsive, and error-free.  
?

 1. Total Pages & Their Purpose
Landing Page

Login Page

Learner Registration (multi-step)

Mentor Registration (multi-step)

Learner Dashboard

Mentor Dashboard

Session Detail & Booking

Cart & Checkout

Payment Callback / Confirmation

Live Session Room

Feedback Modal

Profile / Settings

Admin Panel

Error Pages (401, 404, 500)

👤 2. User-Side Step-By-Step Workflow
2.1 Landing → Login / Register
Landing Page

CTAs: “Login” | “Register as Learner” | “Register as Mentor”

Mentor Carousel & Search bar (filter: free/paid, domain, name)

Errors: none (public page)

Login Page

Inputs: Email, Password

Actions:

Submit → AJAX POST → /api/login/

On 200 OK → redirect to dashboard based on role

On 401 → show inline “Invalid credentials”

On 500 → show “Server error, try again later.”

Learner Registration (4 steps)

Step 1: Name / Email / Password

Real-time email uniqueness check → on conflict show “Email already registered.”

Step 2: Interests (tag input) + AI suggestions via Gemini API

Step 3: Career Goal (dropdown + free text)

Step 4: Profile Picture upload → validate file type/size

Final “Submit” → POST /api/register/learner/

On success → auto-login + redirect /dashboard/learner/

Errors per step: missing fields, invalid formats (email, password strength), upload failures.

Mentor Registration (4 steps)

Step 1: Name / Email / Password (with uniqueness check)

Step 2: Domain Expertise (tags), Skills (tags)

Step 3: Bio (required), Profile Image, Intro Video URL/upload (validate size & format)

Step 4: Availability (optional slots)

Submit → POST /api/register/mentor/ → status = “pending”

Show “Pending Approval” page.

Errors: same validation + file upload errors.

2.2 Learner Dashboard
Header & Sidebar

Search bar (live filter + AI autocomplete)

Nav: Live Sessions | Mentors | My Posts | My Bookings | Cart | Profile

Live Sessions View

Infinite scroll cards: Thumbnail, Title, Mentor, Time, “Book” button

Click “Book” → opens Session Detail modal

Session Detail & Booking

Shows full description, tags, free/paid badge, date/time picker (confirm slot)

If Free → “Confirm Booking” → POST /api/book/ → on success show toast “Booked!”

If Paid → “Add to Cart” → update Cart icon counter

Errors: slot conflict (“Mentor not available”), network errors

Cart & Checkout

List of paid sessions → “Checkout” button

Click → create Razorpay Order via backend → init Razorpay Checkout JS

On payment success → POST /api/payment/verify/

On success → mark booking confirmed, send calendar invite

Errors: payment failure (show retry), order creation failure

My Bookings

Upcoming: show “Join” button 10 min prior → links to /session/<room_id>/

Past: show recording download link (if recorded)

Errors: “Session canceled by mentor” banner

My Posts

Form: Topic, Duration, Preferred Time

“Post Request” → POST /api/learner/posts/ → appear in Mentor Dashboard

Status updates via WebSocket: Open → Requested → Accepted/Declined

Profile & Settings

Edit fields, change password, toggle dark/light mode (persist in user profile + localStorage)

2.3 Mentor Dashboard
Dashboard Overview

Earnings summary, pending bookings count

Create Session

Form: Title, Description, Tags, Thumbnail, Free toggle (hides price), Price (INR), Schedule datetime, Duration

POST /api/mentor/sessions/ → on success adds to Live Sessions list

Errors: overlapping time (“You already have a session then”), invalid input

Booking Requests

List of learner posts → “Respond” button → propose time & rate → POST /api/mentor/respond/

On learner accept & pay → booking confirmed

My Sessions

Upcoming: “Join” button

Past: rating summary & feedback

Actions: Edit / Cancel (cancellation triggers refund workflow)

Errors: cancellation too late (“Cannot cancel within 1 hr”), network issues

Analytics & Payments

Charts for revenue, sessions taught, ratings

Withdrawal requests → POST /api/mentor/withdraw/ → uses Razorpay Payouts (future)

Profile

Show completeness meter, prompt to fill missing Bio/Video

2.4 Live Session Room
URL: /session/<room_id>/

On page load:

Backend checks: user is mentor or booked learner — else 403

Connect WebSocket: ws://…/ws/video/<room_id>/

Exchange SDP & ICE, build WebRTC peer connection

UI: video frames, controls (mute, camera, share screen, raise hand), chat, timer

Errors:

Media access denied → show modal “Allow camera/mic”

Connection lost → “Reconnecting…” banner + retry logic

If cannot reconnect after 3 attempts → “Session ended due to network” + feedback modal

2.5 Feedback Modal
After session end or manual leave: open modal

Rating (1–5 stars) + comment textbox

POST /api/feedback/ → “Thanks for your feedback!” toast

Errors: submission fail → retry option

⚙️ 3. Backend Detailed Steps (Django + SQLite3)
3.1 Setup Razorpay Credentials
python
Copy
Edit
# settings.py
RAZORPAY_KEY_ID     = "rzp_test_ebT608Q3yd4RCS"
RAZORPAY_KEY_SECRET = "mGosJfwuEiL1GndUI2kicrL7"
3.2 Create Razorpay Order
python
Copy
Edit
# video/views.py
import razorpay
from django.conf import settings
from django.views.decorators.csrf import csrf_exempt
from django.http import JsonResponse

client = razorpay.Client(auth=(settings.RAZORPAY_KEY_ID, settings.RAZORPAY_KEY_SECRET))

def create_order(request):
    data = json.loads(request.body)
    amount = int(data['amount'] * 100)  # in paise
    order = client.order.create({
        'amount': amount,
        'currency': 'INR',
        'payment_capture': '1'
    })
    return JsonResponse({'order_id': order['id'], 'amount': amount})
3.3 Verify Payment Signature
python
Copy
Edit
@csrf_exempt
def verify_payment(request):
    data = json.loads(request.body)
    params = {
      'razorpay_order_id': data['order_id'],
      'razorpay_payment_id': data['payment_id'],
      'razorpay_signature': data['signature']
    }
    try:
        client.utility.verify_payment_signature(params)
        # mark booking as paid
        return JsonResponse({'status': 'success'})
    except razorpay.errors.SignatureVerificationError:
        return JsonResponse({'status': 'failure'}, status=400)
3.4 Booking Workflow
Learner clicks “Book” → frontend POSTs to /api/create_order/ → returns order_id.

Init Razorpay Checkout with order_id, key_id.

On success callback → send payment_id, signature to /api/verify_payment/.

On verify success → save Booking(status=‘confirmed’), send email + calendar invite.

3.5 Error Handling
Order creation fails → return 500 + “Unable to place order, try again.”

Payment verify fails → return 400 + “Payment verification failed, please retry.”

Database errors → capture in Sentry, return 500 + “Server error.”

✅ 4. Summary & Cross-Checks
✔️ All pages have clear user flow & error states.

✔️ Backend covers order creation, signature verification, booking logic.

✔️ WebSockets handle live class signaling + reconnect logic.

✔️ Payments are tested in Razorpay Test Mode with your keys.

✔️ Error handling at every step – form, payment, video, network.

✔️ Mobile & desktop responsive.

✔️ Future scale by swapping SQLite → PostgreSQL via Django settings.

┌─────────────────────────────────────────────────────────┐
│ Top Nav: Logo | Live Sessions | Mentors | Search 🔍 |  │
│         | Notifications 🔔 | Profile Avatar (▼)     │
├─────────────────────────────────────────────────────────┤
│ Hero Stats Panel                                  [#] │
│ ┌───────────────────────────────────────────────────┐ │
│ │ “Welcome back, [Name]!”                          │ │
│ │ Average Progress: 78%   Level: Advanced (badge)  │ │
│ │ [Progress Bar: 78% filled, animated on load]     │ │
│ └───────────────────────────────────────────────────┘ │
├─────────────────────────────────────────────────────────┤
│ 📈 Activity Chart & Metrics Panel                   [#]│
│ ┌─────────┬─────────┬─────────┬─────────┐               │
│ │ 1.5h    │ 10 Lsn  │ 61 Audio│ 44 Total│               │
│ │ Spent   │ Passed  │ Listened│ Sessions│               │
│ └─────────┴─────────┴─────────┴─────────┘               │
│ ┌───────────────────────────────────────────────────┐ │
│ │ Line chart: Monthly activity + tooltips on hover │ │
│ └───────────────────────────────────────────────────┘ │
├─────────────────────────────────────────────────────────┤
│ 🏅 Achievements & Badges                             │
│ ┌───────────────────────────────────────────────────┐ │
│ │ • 5 Sessions Completed   [trophy icon]            │ │
│ │ • “Python Pro” Badge      [ribbon icon]           │ │
│ │ • Referral Bonus: 10 pts [gift icon]              │ │
│ └───────────────────────────────────────────────────┘ │
├─────────────────────────────────────────────────────────┤
│ 🔥 Recommended Live Sessions                         │
│ [Filter: Free/Paid | Domain Dropdown | Time Slots]    │
│ ┌───────────────────────────────────────────────────┐ │
│ │ Card (glass effect):                              │ │
│ │   – Thumbnail + “LIVE” ribbon                      │ │
│ │   – Title: “Intro to ML”                           │ │
│ │   – Mentor: Jane Doe  ★4.9 (150)                   │ │
│ │   – Time: May 5, 3–4PM  | Free                     │ │
│ │   – “Book Now” button (hover glow + pulsing)       │ │
│ └───────────────────────────────────────────────────┘ │
│ (repeat cards in horizontal scroll on mobile)        │ │
├─────────────────────────────────────────────────────────┤
│ 💬 Quick Chat & Tips Panel                           │
│ ┌───────────────────────────────────────────────────┐ │
│ │ “Need help? Ask our AI tutor”  [Chat icon]         │ │
│ │ [Input box: “Type your question…”] [Send button]   │ │
│ └───────────────────────────────────────────────────┘ │
├─────────────────────────────────────────────────────────┤
│ 📝 Recent Feedback                                    │
│ ┌───────────────────────────────────────────────────┐ │
│ │ “Great explanation on regression!” — ⭐⭐⭐⭐⭐         │ │
│ │ “Loved the live session with Jane.” — ⭐⭐⭐⭐          │ │
│ └───────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────┘

 Key Components & Design Notes
Hero Stats Panel

Progress Ring or bar (animates in on page load).

Level Badge (e.g. bronze/silver/gold) with hover tooltip “Next level at 85%.”

Illustration: an unDraw “learner at podium” or “pencil rocket.”

Activity Chart & Metrics

Line Chart (use Chart.js or Recharts) for monthly hours.

4 metric cards beneath it (hours, lessons, audios, total sessions).

Micro-interactions: on hover, cards lift and show “View Details.”

Achievements & Badges

Horizontal list of circular badge cards.

Badges greyed-out if locked; colored if earned.

Hover: show “Earn this by completing 3 more sessions.”

Recommended Live Sessions

Glassmorphism cards: semi-transparent background + backdrop-filter blur.

“LIVE” ribbon badge top-left.

Buttons with pulsing CSS animation.

┌───────────────────────────────────────────────────────────────────────┐
│ Top Nav: Logo | Live Sessions | Learners | Analytics | Search 🔍 | 🔔 │
│             Profile Avatar (▼)                                     │
├───────────────┬───────────────────────────────────────────────────────┤
│ **Side Nav**  │ **Main Content Area**                                │
│               │                                                       │
│ • Dashboard   │ 1️⃣ **Quick Stats Row**                              │
│ • My Sessions │   ┌─────────┬──────────┬──────────┬───────────┐      │
│ • Requests    │   │ 📅 5 Upcoming │ 🔔 2 Pending │ 💰 ₹12.3K  │ 🏆 3 Badges│ │
│ • Learners    │   └─────────┴──────────┴──────────┴───────────┘      │
│ • Analytics   │                                                       │
│ • Earnings    │ 2️⃣ **Your Top Learners** (avatars carousel)         │
│ • Messages    │   [ ◀ avatar • avatar • avatar • avatar ▶ ]        │
│ • Profile     │                                                       │
│ • Settings    │ 3️⃣ **Streak & Badges**                            │
│               │   ┌───────────────────────────────────────────────┐ │
│               │   │ 🔥 10-day teaching streak      🎖️ “Top Mentor”    │ │
│               │   │ 📈 “Session Master” badge (50+ sessions)     │ │
│               │   └───────────────────────────────────────────────┘ │
│               │                                                       │
│               │ 4️⃣ **Upcoming Sessions** (horizontal cards)        │
│               │   ┌───────────────────────────────────────────────┐ │
│               │   │ Thumbnail | Title: “Intro to Python”           │ │
│               │   │ Date/Time | Learner: John Doe                  │ │
│               │   │ Duration | Status: Booked                    │ │
│               │   │ [ Join ] button (glow on hover)               │ │
│               │   └───────────────────────────────────────────────┘ │
│               │                                                       │
│               │ 5️⃣ **Performance Chart**                          │
│               │   ┌───────────────────────────────────────────────┐ │
│               │   │ Bar/Line chart: Sessions taught per month      │ │
│               │   │ Tooltip: “Aug: 12 sessions”                    │ │
│               │   └───────────────────────────────────────────────┘ │
│               │                                                       │
│               │ 6️⃣ **Quick Actions**                               │
│               │   • Create New Session  (+)                        │ │
│               │   • Respond to Learner Requests                   │ │
│               │   • View Earnings                                 │ │
│               │                                                       │
│               │ 7️⃣ **Recent Feedback**                            │
│               │   ┌───────────────────────────────────────────────┐ │
│               │   │ “Great session on loops!” — ⭐⭐⭐⭐⭐ — Jane L.      │ │
│               │   └───────────────────────────────────────────────┘ │
│               │                                                       │
│               │ […more as you scroll…]                                │
└───────────────┴───────────────────────────────────────────────────────┘

🔑 Key Components & Details
Quick Stats Row

Upcoming Sessions count with calendar icon

Pending Requests badge (WebSocket real-time count)

Earnings total (₹) with sparkline

Badges Earned count (click → badge gallery modal)

Your Top Learners

Horizontally scrollable avatar list

On Hover: show name, last session date, rating

Click: open learner profile pop-up

Streak & Badges

Gamified streak tracker (e.g. “🔥 10-day teaching streak”)

Key badges in capsule cards: hover reveals “Criteria: 50 sessions completed”

Upcoming Sessions

Glassmorphism cards with thumbnail, session title, date/time, learner name

Join Button: pulsating on hover; disabled if not within join window

Status Indicator: color-coded (green=Confirmed, yellow=Pending, red=Canceled)

Performance Chart

Chart.js or Recharts component

Monthly sessions taught; color highlights for record months

On Hover: detailed tooltips

Quick Actions

Floating action button “+ Create Session”

Buttons: “View Booking Requests”, “Payout Requests”

Recent Feedback

Card list of last 5 feedback comments

Star ratings, learner name, short quote

On Click: opens full feedback in sidebar panel

🎨 Visual Style & Interactions
Color Palette:

Accent Orange #FF5734, Accent Purple #BE94F5

Neutral Light Gray #F7F7F5, Dark Text #151515

Typography:

Headlines: Poppins Bold 24–32px

Body: Inter Regular 14–16px

Shadows & Glass:

Card shadow: 0 6px 20px rgba(0,0,0,0.05)

Glass blur panels: backdrop-filter: blur(12px); background: rgba(255,255,255,0.6);

Animations:

Use GSAP for entry animations

Hover lift: transform: translateY(-4px); + shadow intensify

Button pulse: keyframe grow/shrink every 2s

Responsive Behavior:

Desktop: Side nav always visible

Tablet: Side nav collapsible, stats row wraps to two rows

Mobile: Bottom nav bar (icons for Home, Sessions, Requests, Profile)

Cards stack vertically; horizontal carousels swipe-enabled

✅ Error Handling & Edge Cases
No Upcoming Sessions: show empty state with “Create your first session” CTA

Chart Data Fail: “Unable to load analytics. Retry” with refresh icon

Network Offline: sticky banner “You’re offline — reconnecting…”

Action Failures: toast notifications for errors in real-time (booking, cancel, join)

🔄 Hidden Logic & Flows
Real-Time Updates:

WebSocket pushes when new booking request arrives

Stats row auto-updates earnings & pending count

Access Control:

Only approved mentors see this dashboard

Unauthorized → redirect to registration or “Pending Approval” page

Session Join Window:

Join button enabled from 10min before start until end time + 5min

Badge Unlocking:

After each session, check if new badge criteria met → auto-grant & notify
┌───────────────────────────────────────────────────────────────────────┐
│ Top Bar: [Back ←]  Session Title  •  Timer (01:23:45)               │
│          • Mute All Chats  • Record (● REC)  • Settings ⚙️           │
│          • Notifications 🔔  • Profile Avatar (▼)                   │
├────────────────────────────┬──────────────────────────────────────────┤
│         Video Area         │  Right Pane: AI & Agenda               │
│ ┌───────────────────────┐ │  ┌────────────────────────────────────┐ │
│ │ [ Mentor Video Frame ]│ │  │ Meeting Topic Analyzer              │ │
│ │  • Pin/Unpin          │ │  │ — UI Design Session       80% Match │ │
│ │  • Mute/Unmute mic    │ │  │ — Fundamental Session    90% Match │ │
│ │  • Camera On/Off      │ │  │ • Hover → show key excerpts        │ │
│ └───────────────────────┘ │  ├────────────────────────────────────┤ │
│ ┌───────────────────────┐ │  │ Today’s Agenda                      │ │
│ │ [ Learner Video Frame ]│ │  │ 1. Intro & Goals (5m)                │ │
│ │  • Pin/Unpin           │ │  │ 2. Core Content (45m)                │ │
│ │  • Raise Hand Button   │ │  │ 3. Q&A (10m)                         │ │
│ └───────────────────────┘ │  ├────────────────────────────────────┤ │
│                           │  │ Action Items                         │ │
│        Controls ↓         │  │ • “Summarize key takeaways” (Next)   │ │
│  [ Mic ⚪ ] [ Cam ⚪ ]      │  │ • “Create follow-up task” (Skip)      │ │
│  [ Share Screen ]         │  │                                    │ │
│  [ Whiteboard ]           │  │                                    │ │
│  [ Chat Toggle ]          │  └────────────────────────────────────┘ │
├────────────────────────────┴──────────────────────────────────────────┤
│ 📜 **Transcript & Live Captions** (collapsible bottom pane)           │
│ — “Oliver: Let’s start with the dashboard design…”                   │
│ — “Kurt: Sure, notice how the KPI cards…”                            │
│ [ Toggle Auto-Scroll ]  [ Download Transcript ]                      │
└───────────────────────────────────────────────────────────────────────┘
 Feature Breakdown
Top Bar Essentials

Session Title + Timer: always visible

Global Controls:

Record toggle (show REC indicator)

Mute all chats

Quick settings (video quality, bandwidth)

Video Area

Peer Videos: large, side-by-side or stacked on mobile

Pin / Unpin: let either user lock the main speaker’s video

Raise Hand: learner can request focus—mentor sees a subtle badge

AI-Powered Sidebar

Meeting Topic Analyzer: real-time ML that extracts 3–5 key topics, with progress bars indicating “how much of the session has covered each topic.”

Hover any topic → shows the exact transcript snippets where that topic was discussed.

Agenda & Action Items

Pre-loaded Agenda from mentor’s session creation form

Countdown per item (e.g. “Core Content – 32m left”)

Action Items: mentor or learner can click “Next” to mark an item done or “Skip” to move on

Sidebar updates in real-time via WebSocket

Transcript & Live Captions

Real-time captions at the bottom, scrolls with the conversation

Download full transcript as .txt or .docx after the class

Toggle Auto-Scroll to pause/resume transcript feed

Advanced Controls

Screen Share with preview thumbnail before sharing

Collaborative Whiteboard (drawing synced via WebSocket)

Chat Panel: text + emoji reactions

Recording Storage: button to download after session

💡 UI/UX & Gamification Touches
Glass Panels & Soft Shadows on all sidebars

Micro-animations:

Pin/unpin slides smoothly

Progress bars fill as time elapses

Agenda items highlight in sequence

Responsive Behavior:

Mobile: Video occupies full width; sidebar becomes a bottom sheet you swipe up for “Topics/Agenda”

Tablet: split view, adjustable pane widths

🔒 Error Handling & Network Resilience
Low Bandwidth Mode: one-click switch to audio-only + lower resolution

Auto-Reconnect: on ICE failure, retry up to 3× before showing “Connection lost” banner

Media Permissions: clear modals if camera/mic denied, with “Retry” button

Recording Failure: warn “Recording unavailable, please retry or contact support.”

🔄 Hidden Workflows & Data Flows
Before Session: Mentor’s agenda & AI tags pushed to sidebar via API

During Session:

Transcript → sent to Gemini-style API for live topic extraction

WebSocket → synchronizes agenda progress, action items

After Session:

Auto-save transcript + recording to user’s dashboard

Prompt feedback modal (⭐ rating + comments)

📱 Mobile-First Considerations
Bottom Sheet for agenda & topics

Floating buttons for “Leave Call” & “Raise Hand”

Swipe gestures to switch between video and controls
 dedicated UI/UX blueprint for your Login + Gamified Multi-Step Registration flow—designed to feel premium on Web & Mobile, fully responsive, and packed with fun illustrations and micro-animations.

🎨 Visual Style & Assets
Color Palette

Primary Orange #FF5734

Accent Purple #BE94F5

Highlight Yellow #FCCC42

Neutral Light #F7F7F5

Text Dark #151515

Typography

Headlines: Poppins-Bold

Body: Inter-Regular

Illustrations

Lottie/JSON animations for “Welcome,” “High-five” moments

unDraw / Storyset SVGs for “unlock,” “map,” “trophy,” “rocket”

Micro-interactions

Button ripple + pulse on CTA

Field border glow on focus

Step-transition slide + fade

🖥️ Web & 📱 Mobile Screens
1. Login Screen
scss
Copy
Edit
┌────────────────────────────────────────────┐
│ Logo (top-center)                         │
│ “Welcome Back!” (H1)                      │
│ [ Illustration: person unlocking door ]   │
│ Email  [__________]                       │
│ Password [__________] (eye-toggle)        │
│ [Login  ▶] (pulse animation)              │
│                                           │
│ — or —                                    │
│ [Login with Google]  [Login with Facebook]│
│                                           │
│ Don’t have an account? [Sign Up →]        │
└────────────────────────────────────────────┘
Errors:

Invalid creds → shake form + red banner “Email or password incorrect.”

Field empty → inline “Required” under field.

Responsive:

Web: center card, 400px wide.

Mobile: full-width card with 16px padding.

2. Registration Flow Overview
4 Steps, each as its own full-screen (or card) with progress indicator (dots or “Step 1 of 4”).

Slide-in transition left-to-right on “Next”; right-to-left on “Back.”

2.1 Step 1: Basic Info
markdown
Copy
Edit
┌────────────────────────────────────────┐
│ ← Back        Step 1 of 4             │
│ [Illustration: “Hello!” waving hand]  │
│ Full Name                              │
│ [____________]                         │
│ Email                                  │
│ [____________] (live-validate unique)  │
│ Password (eye-toggle strength bar)     │
│ [Next →]                               │
└────────────────────────────────────────┘
Gamification: show a small trophy icon “Complete step 1 to unlock badge!”

Error Handling:

Email exists → inline “Looks like you’re already here—please log in.”

Weak password → red strength bar “Too weak.”

2.2 Step 2: Select Interests
less
Copy
Edit
┌────────────────────────────────────────┐
│ ← Back        Step 2 of 4             │
│ [Illustration: “Map & Pin”]           │
│ What topics excite you?               │
│ [ Search tags… ]                       │
│ Suggestions: [Python] [ML] [Design]   │
│ (Select up to 5)                       │
│ [Next →]                               │
└────────────────────────────────────────┘
AI SUGGEST: as user types, call Gemini API for trending topics.

Max-select: after 5 tags, disable others + show tooltip “Max 5.”

2.3 Step 3: Career Goal
css
Copy
Edit
┌────────────────────────────────────────┐
│ ← Back        Step 3 of 4             │
│ [Illustration: “Rocket launch”]       │
│ “I want to become…”                   │
│ [ Dropdown: Machine Learning Engineer ]│
│ OR Type custom goal…                  │
│ [Next →]                               │
└────────────────────────────────────────┘
Pre-populate popular goals from your database.

Error: none if empty (optional), but show “Don’t miss out—set a goal!” tooltip if blank.

2.4 Step 4: Profile Picture & Avatar
css
Copy
Edit
┌────────────────────────────────────────┐
│ ← Back        Step 4 of 4             │
│ [Illustration: “Avatar placeholder”]  │
│ Upload a Profile Picture               │
│ [ Upload Button ]                      │
│ OR Choose Avatar Emoji                 │
│ [Finish & Go to Dashboard →]           │
└────────────────────────────────────────┘
File Validations:

Type: JPEG/PNG only; Size ≤ 2MB → inline error.

Gamify: show a “Welcome [Name]! 🎉” confetti animation on submit.

3. Final Confirmation
Auto-login and redirect to Learner Dashboard.

Celebrate: full-screen confetti overlay for 2s: “You’re all set—explore your first session!”

📱 Mobile-Specific Tweaks
Use bottom navigation for multi-step (swipe left/right as well).

Sticky Next button at bottom.

Illustrations centered above form fields.

Progress dots just below the top bar.

💡 Extra Gamification & Micro-UX
Progress Meter at top of each step (colored bar).

Reward Points: show “+10 XP” badge on completing each step.

Sound FX: subtle “ping” on Next.

Unlock Screen: after step 2, show “You’ve unlocked the ‘Explorer’ badge!” modal.

✅ Error-Free Flow
Network Fail: “Unable to connect. Retry” toast.

Form Validation: real-time via AJAX.

Timeout: if inactive for 2 minutes, show “Are you still there?” alert.

🚀 Implementation Notes
Build as React components (or Django templates + Alpine.js)

Use TailwindCSS for rapid styling

Illustrations loaded as SVG / Lottie for crisp scaling

Store partial registration data in localStorage so users can resume

?


